"use strict";
(self.webpackJsonp__wix_thunderbolt_app =
  self.webpackJsonp__wix_thunderbolt_app || []).push([
  [3909],
  {
    94208: function (t, e, a) {
      a.r(e),
        a.d(e, {
          AnimationManager: function () {
            return p;
          },
          MotionSymbol: function () {
            return l.h;
          },
          page: function () {
            return nr;
          },
        });
      var r = a(77748),
        n = a(20590),
        o = a(39218),
        s = a(87711),
        i = a(32166),
        c = a(54157),
        l = a(59058),
        f = a(82658),
        m = a(82634);
      class p {
        constructor(t, e, a) {
          (this.api = t),
            (this.viewportManager = e({ manager: this })),
            (this.isResponsive = a),
            (this.animationData = {}),
            (this.scrubManagers = []),
            (this.scrubTriggers = {}),
            (this.callbacks = {}),
            (this.breakpointRanges = []),
            (this.activeListeners = []),
            (this.scrubUpdateRequest = null),
            (this.breakpointChangeHandler =
              this._breakpointChangeHandler.bind(this)),
            (this.disabledPointerScenes = {}),
            (this.played = {});
        }
        init(t, e) {
          (this.animationData = t),
            (this.breakpointRanges = e),
            (this.scrubUpdateRequest = null),
            this._observeBreakpointChange();
        }
        trigger(t = {}, e) {
          if (t.scrub)
            return void (e
              ? ((this.scrubTriggers = t.scrub),
                this.scrubUpdateRequest ||
                  (this.scrubUpdateRequest = setTimeout(() => {
                    this._updateScrubManagers(this.scrubTriggers, !0),
                      (this.scrubUpdateRequest = null);
                  }, 0)))
              : (Object.assign(this.scrubTriggers, t.scrub),
                this._updateScrubManagers(t.scrub)));
          const a = this.isResponsive ? window.innerWidth : 0;
          t.play?.length &&
            t.play.forEach(({ effectId: t, targetId: e, toggle: r }) => {
              const n = this._getEffectVariationForCurrentBreakpoint(t, a);
              n.namedEffect &&
                this._playAnimation(n, t, { targetId: e, toggle: r });
            }),
            t.resume?.length &&
              t.resume.forEach(({ effectId: t, targetId: e }) => {
                if (this.disabledPointerScenes[t])
                  return void this.disabledPointerScenes[t].forEach(
                    (t) => (t.disabled = !1)
                  );
                const r = this._getEffectVariationForCurrentBreakpoint(t, a);
                r.namedEffect &&
                  this._resumeOrPlayAnimation(r, t, { targetId: e });
              }),
            t.hold?.length &&
              t.hold.forEach(({ effectId: t, targetId: e }) => {
                if (this.disabledPointerScenes[t])
                  return void this.disabledPointerScenes[t].forEach(
                    (t) => (t.disabled = !0)
                  );
                this._getEffectVariationForCurrentBreakpoint(t, a)
                  .namedEffect && this._pauseAnimation(t, e);
              });
        }
        clear() {
          (this.animationData = {}),
            this.activeListeners.forEach((t) =>
              t.removeEventListener("change", this.breakpointChangeHandler)
            ),
            (this.activeListeners.length = 0),
            (this.disabledPointerScenes = {}),
            this.viewportManager.disconnect();
        }
        addEffectCallback(t, e, a) {
          const r = "animation-end" === e ? "end" : "start";
          this.callbacks[t] || (this.callbacks[t] = { end: [], start: [] }),
            this.callbacks[t][r].push(a);
        }
        clearEffectCallbacks(t) {
          delete this.callbacks[t];
        }
        _updateScrubManagers(t = {}, e = !1) {
          this.scrubManagers.length &&
            e &&
            (this.scrubManagers.forEach((t) => t.destroy()),
            (this.scrubManagers.length = 0));
          const a = Object.keys(t),
            r = this.isResponsive ? window.innerWidth : 0,
            n = {};
          for (const t of a) {
            const e = this._getEffectVariationForCurrentBreakpoint(t, r);
            "ScrubAnimationOptions" === e.type && (n[t] = e);
          }
          this.scrubManagers.push(...this.api.startScrub(t, n)),
            this.scrubManagers.forEach((t) => {
              t instanceof m.g &&
                t.config.scenes.forEach((t) => {
                  if (t.target && t.centeredToTarget && t.isHitAreaRoot) {
                    const e = t.target.closest("[data-block-level-container]"),
                      a = t.effectId;
                    e &&
                      this.viewportManager &&
                      a &&
                      (this.disabledPointerScenes[a] ||
                        (this.disabledPointerScenes[a] = []),
                      this.disabledPointerScenes[a].push(t),
                      this.viewportManager.observe(e, {
                        effectId: a,
                        targetId: t.target.id,
                      }));
                  }
                });
            });
        }
        _getEffectVariationForCurrentBreakpoint(t, e) {
          const a = this.animationData[t].find((t) => !t.variants?.length);
          return (
            (e &&
              this.animationData[t].findLast((t) =>
                t.variants?.some(
                  (t) => !(t.max && t.max < e) && !(t.min && t.min > e)
                )
              )) ||
            a
          );
        }
        _playAnimation(t, e, a = {}) {
          const r = { ...t, ...a, effectId: e },
            { targetId: n, iterations: o, allowReplay: s } = r;
          if (0 === o) return void this._setAnimationPlaystateTrigger(e, n);
          if ("never" === s && this.played[n])
            return void this._setAnimationState(n);
          const i = this._getAnimationCallbacks(e, n, r);
          this.api.play(n, r, i), (this.played[n] = !0);
        }
        _resumeOrPlayAnimation(t, e, a = {}) {
          const r = { ...t, ...a, effectId: e },
            n = r.targetId,
            o = this.api.getTargetAnimation(n, e),
            s = this._getAnimationCallbacks(e, n, r);
          o ? o.play() : this.api.play(n, r, s);
        }
        _pauseAnimation(t, e) {
          const a = this.api.getTargetAnimation(t, e);
          a?.pause();
        }
        _setAnimationPlaystateTrigger(t, e) {
          const a = document.getElementById(e);
          if (a && this.viewportManager) {
            const r = a.closest("[data-block-level-container]") || a;
            this.viewportManager.observe(r, { effectId: t, targetId: e });
          }
        }
        _observeBreakpointChange() {
          this.breakpointRanges.forEach((t) => {
            const e = u(t),
              a = window.matchMedia(e);
            this.activeListeners.push(a),
              a.addEventListener("change", this.breakpointChangeHandler);
          });
        }
        _breakpointChangeHandler(t) {
          t.matches &&
            (this.scrubUpdateRequest ||
              (this.scrubUpdateRequest = setTimeout(() => {
                this._updateScrubManagers(this.scrubTriggers, !0),
                  (this.scrubUpdateRequest = null);
              }, 0)));
        }
        _setAnimationState(t) {
          const e = document.getElementById(t);
          e && (e.dataset.motionEnter = "done");
        }
        _getAnimationCallbacks(t, e, a) {
          const r = [];
          return (
            ("backwards" !== a.fill && "both" !== a.fill) ||
              r.push(() => {
                this._setAnimationState(e);
              }),
            r.push(...(this.callbacks[t]?.start || [])),
            { start: r, end: this.callbacks[t]?.end }
          );
        }
      }
      const u = (t) => {
        const e = [];
        return (
          t.max && e.push(`(max-width:${t.max}px)`),
          t.min && e.push(`(min-width:${t.min}px)`),
          e.join(" and ")
        );
      };
      var d = a(8242),
        g = a(49432);
      const y = { vertical: "rotateX", horizontal: "rotateY" },
        h = {
          in: { fromValue: -68, toValue: 0 },
          out: { fromValue: 0, toValue: 68 },
          continuous: { fromValue: -68, toValue: 68 },
        };
      const v = { soft: 6, medium: 25, hard: 50 };
      const $ = { soft: 60, medium: 120, hard: 420 },
        x = { vertical: "rotateX", horizontal: "rotateY" };
      const b = 40,
        k = {
          soft: { scaleFrom: 0.8, scaleTo: 1.2, travelY: 0 },
          medium: { scaleFrom: 0.3, scaleTo: 1.7, travelY: 0.75 },
          hard: { scaleFrom: 0, scaleTo: 4, travelY: 1 },
        },
        w = {
          top: [0, -50],
          "top-right": [50, -50],
          right: [50, 0],
          "bottom-right": [50, 50],
          bottom: [0, 50],
          "bottom-left": [-50, 50],
          left: [-50, 0],
          "top-left": [-50, -50],
          center: [0, 0],
        },
        E = {
          in: (t, e, a) => ({
            fromValues: { scale: t, travel: a },
            toValues: { scale: 1, travel: 0 },
          }),
          out: (t, e, a) => ({
            fromValues: { scale: 1, travel: 0 },
            toValues: { scale: e, travel: -a },
          }),
          continuous: (t, e, a) => ({
            fromValues: { scale: t, travel: a },
            toValues: { scale: e, travel: -a },
          }),
        };
      var Y = a(81220),
        O = Y.S7;
      const I = {
        initial: (t) => {
          let { top: e, bottom: a, left: r, right: n } = t;
          return `${r}% ${e}%, ${n}% ${e}%, ${n}% ${a}%, ${r}% ${a}%`;
        },
        top: (t) => {
          let { top: e, left: a, right: r, minimum: n } = t;
          return `${a}% ${e}%, ${r}% ${e}%, ${r}% ${e + n}%, ${a}% ${e + n}%`;
        },
        right: (t) => {
          let { top: e, bottom: a, right: r, minimum: n } = t;
          return `${r - n}% ${e}%, ${r}% ${e}%, ${r}% ${a}%, ${r - n}% ${a}%`;
        },
        center: (t) => {
          let { centerX: e, centerY: a, minimum: r } = t;
          return `${e - r / 2}% ${a - r / 2}%, ${e + r / 2}% ${a - r / 2}%, ${
            e + r / 2
          }% ${a + r / 2}%, ${e - r / 2}% ${a + r / 2}%`;
        },
        bottom: (t) => {
          let { bottom: e, left: a, right: r, minimum: n } = t;
          return `${a}% ${e - n}%, ${r}% ${e - n}%, ${r}% ${e}%, ${a}% ${e}%`;
        },
        left: (t) => {
          let { top: e, bottom: a, left: r, minimum: n } = t;
          return `${r}% ${e}%, ${r + n}% ${e}%, ${r + n}% ${a}%, ${r}% ${a}%`;
        },
        vertical: (t) => {
          let { top: e, bottom: a, left: r, right: n, minimum: o } = t;
          return `${r}% ${e + o / 2}%, ${n}% ${e + o / 2}%, ${n}% ${
            a - o / 2
          }%, ${r}% ${a - o / 2}%`;
        },
        horizontal: (t) => {
          let { top: e, bottom: a, left: r, right: n, minimum: o } = t;
          return `${r + o / 2}% ${e}%, ${n - o / 2}% ${e}%, ${
            n - o / 2
          }% ${a}%, ${r + o / 2}% ${a}%`;
        },
      };
      function P(t) {
        let { direction: e, scaleX: a = 1, scaleY: r = 1, minimum: n = 0 } = t;
        const o = ((1 - r) / 2) * 100,
          s = ((1 - a) / 2) * 100,
          i = 100 + s - 100 * (1 - a),
          c = 100 + o - 100 * (1 - r),
          l = (i + s) / 2,
          f = (c + o) / 2;
        return `polygon(${I[e]({
          top: o,
          bottom: c,
          left: s,
          right: i,
          centerX: l,
          centerY: f,
          minimum: n,
        })})`;
      }
      function z(t, e, a) {
        const r = t.indexOf(e),
          n = t.length;
        return t[(r + (n - 1) * Math.round(((a || 0) / 360) * n)) % n];
      }
      function X(t, e) {
        const a = (t * Math.PI) / 180;
        return [Math.cos(a) * e, Math.sin(a) * e];
      }
      function _(t) {
        return "percentage" === t ? "%" : t || "px";
      }
      function S(t) {
        return t ? O[t] || t : O.linear;
      }
      function T(t) {
        const e = t.replace(/In|Out/g, "");
        return "linear" === e
          ? { in: "linear", inOut: "linear", out: "linear" }
          : { in: `${e}In`, inOut: `${e}InOut`, out: `${e}Out` };
      }
      const M = {
        linear: "linear",
        easeOut: "ease-out",
        hardBackOut: "cubic-bezier(0.58, 2.5, 0, 0.95)",
        elastic:
          "linear( 0, 0.2178 2.1%, 1.1144 8.49%, 1.2959 10.7%, 1.3463 11.81%, 1.3705 12.94%, 1.3726, 1.3643 14.48%, 1.3151 16.2%, 1.0317 21.81%, 0.941 24.01%, 0.8912 25.91%, 0.8694 27.84%, 0.8698 29.21%, 0.8824 30.71%, 1.0122 38.33%, 1.0357, 1.046 42.71%, 1.0416 45.7%, 0.9961 53.26%, 0.9839 57.54%, 0.9853 60.71%, 1.0012 68.14%, 1.0056 72.24%, 0.9981 86.66%, 1 )",
        bounce:
          "linear( 0, 0.0039, 0.0157, 0.0352, 0.0625 9.09%, 0.1407, 0.25, 0.3908, 0.5625, 0.7654, 1, 0.8907, 0.8125 45.45%, 0.7852, 0.7657, 0.7539, 0.75, 0.7539, 0.7657, 0.7852, 0.8125 63.64%, 0.8905, 1 72.73%, 0.9727, 0.9532, 0.9414, 0.9375, 0.9414, 0.9531, 0.9726, 1, 0.9883, 0.9844, 0.9883, 1 )",
      };
      function A(t) {
        return (t && M[t]) || "linear";
      }
      function B(t) {
        const e = (t * Math.PI) / 180,
          a = Math.cos(e),
          r = Math.sin(e),
          n = Math.sign(a),
          o = Math.sign(r),
          s = "var(--motion-left, 0px)",
          i = "var(--motion-top, 0px)";
        let c;
        const l = `calc(${
            n ? (-1 === n ? `(-1 * ${s} - 100%)` : `(100vw - ${s})`) : 0
          } / ${a})`,
          f = `calc(${
            o ? (-1 === o ? `(-1 * ${i} - 100%)` : `(100vh - ${i})`) : 0
          } / ${r})`;
        return (
          (c = a ? (r ? `min(${f}, ${l})` : l) : f),
          { x: `calc(${c} * ${a})`, y: `calc(${c} * ${r})` }
        );
      }
      function V(t) {
        let e = 0;
        t.measure((t) => {
          t && (e = t.offsetHeight);
        }),
          t.mutate((t) => {
            null == t || t.style.setProperty("--motion-comp-height", `${e}px`);
          });
      }
      function Z(t, e) {
        let a = t.offsetLeft,
          r = t.offsetTop,
          n = t.offsetParent;
        for (; n && (!e || n !== e); )
          (a += n.offsetLeft), (r += n.offsetTop), (n = n.offsetParent);
        return { left: a, top: r };
      }
      const R = (t) =>
          t
            .map((t) => {
              let { x: e, y: a } = t;
              return `${e}% ${a}%`;
            })
            .join(", "),
        C = (t, e, a, r, n) => {
          const o = "right" === n || "bottom" === n ? 1 : -1,
            s = "top" === n || "bottom" === n,
            i = o > 0,
            c = [],
            l = [];
          for (let n = t; n !== e; n += o) {
            const t = ((n + o) / a) * 100,
              e = (n / a) * 100;
            let f;
            if (r) {
              const e = i ? 1 + n / a : 1 + (a - n) / a;
              f = i ? t * e : 100 - (100 - t) * e;
            } else f = t;
            s
              ? (c.push(
                  { x: 0, y: e },
                  { x: 100, y: e },
                  { x: 100, y: e },
                  { x: 0, y: e }
                ),
                l.push(
                  { x: 0, y: e },
                  { x: 100, y: e },
                  { x: 100, y: f },
                  { x: 0, y: f }
                ))
              : (c.push(
                  { x: e, y: 0 },
                  { x: e, y: 100 },
                  { x: e, y: 100 },
                  { x: e, y: 0 }
                ),
                l.push(
                  { x: e, y: 0 },
                  { x: e, y: 100 },
                  { x: f, y: 100 },
                  { x: f, y: 0 }
                ));
          }
          return { clipPathStart: c, clipPathEnd: l };
        },
        F = {
          bottom: (t, e) => C(0, t, t, e, "bottom"),
          top: (t, e) => C(t, 0, t, e, "top"),
          right: (t, e) => C(0, t, t, e, "right"),
          left: (t, e) => C(t, 0, t, e, "left"),
        };
      function D(t, e, a, r) {
        const { clipPathStart: n, clipPathEnd: o } = F[t](e, a);
        return (
          r && (n.reverse(), o.reverse()),
          { clipStart: `polygon(${R(n)}`, clipEnd: `polygon(${R(o)})` }
        );
      }
      const G = {
          soft: { value: 150, type: "px" },
          medium: { value: 400, type: "px" },
          hard: { value: 800, type: "px" },
        },
        q = {
          in: (t, e) => ({
            fromValue: { x: t, y: e },
            toValue: { x: 0, y: 0 },
          }),
          out: (t, e) => ({
            fromValue: { x: 0, y: 0 },
            toValue: { x: t, y: e },
          }),
          continuous: (t, e) => ({
            fromValue: { x: t, y: e },
            toValue: { x: -t, y: -e },
          }),
        };
      const H = { left: 1, right: -1 },
        W = {
          left: {
            startX: "calc(var(--motion-left, calc(100vw - 100%)) * -1 - 100%)",
            endX: "calc(100vw - var(--motion-left, 0px))",
          },
          right: {
            startX: "calc(100vw - var(--motion-left, 0px))",
            endX: "calc(var(--motion-left, calc(100vw - 100%)) * -1 - 100%)",
          },
        };
      const L = 0.5;
      function U(t, e) {
        return 100 * t * e + "vh";
      }
      const j = ["bottom", "left", "top", "right"],
        J = { top: "bottom", bottom: "top", left: "right", right: "left" },
        K = P({ direction: "initial" });
      function N(t, e) {
        return "out" === e ? K : P({ direction: J[t] });
      }
      function Q(t, e) {
        return "in" === e ? K : P({ direction: "out" === e ? J[t] : t });
      }
      const tt = {
          diamond: {
            start: {
              soft: "polygon(50% 20%, 80% 50%, 50% 80%, 20% 50%)",
              medium: "polygon(50% 40%, 60% 50%, 50% 60%, 40% 50%)",
              hard: "polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%)",
            },
            end: "polygon(50% -50%, 150% 50%, 50% 150%, -50% 50%)",
          },
          window: {
            start: {
              soft: "inset(20% round 50% 50% 0% 0%)",
              medium: "inset(35% round 50% 50% 0% 0%)",
              hard: "inset(50% round 50% 50% 0% 0%)",
            },
            end: "inset(-20% round 50% 50% 0% 0%)",
          },
          rectangle: {
            start: {
              soft: "inset(20%)",
              medium: "inset(50%)",
              hard: "inset(80%)",
            },
            end: "inset(0%)",
          },
          circle: {
            start: {
              soft: "circle(40%)",
              medium: "circle(25%)",
              hard: "circle(0%)",
            },
            end: "circle(75%)",
          },
          ellipse: {
            start: {
              soft: "ellipse(50% 50%)",
              medium: "ellipse(30% 30%)",
              hard: "ellipse(0% 0%)",
            },
            end: "ellipse(75% 75%)",
          },
        },
        et = {
          diamond: (t) => {
            const e = t / 2,
              a = 100 - e;
            return [
              `polygon(50% ${e}%, ${a}% 50%, 50% ${a}%, ${e}% 50%)`,
              "polygon(50% -50%, 150% 50%, 50% 150%, -50% 50%)",
            ];
          },
          window: (t) => [
            `inset(${t / 2}% round 50% 50% 0% 0%)`,
            "inset(-20% round 50% 50% 0% 0%)",
          ],
          rectangle: (t) => [`inset(${t}%)`, "inset(0%)"],
          circle: (t) => [`circle(${100 - t}%)`, "circle(75%)"],
          ellipse: (t) => {
            const e = 50 - t / 2;
            return [`ellipse(${e}% ${e}%)`, "ellipse(75% 75%)"];
          },
        },
        at = S("circInOut"),
        rt = {
          in: (t, e) => [{ clipPath: t, easing: at }, { clipPath: e }],
          out: (t, e) => [{ clipPath: e, easing: at }, { clipPath: t }],
          continuous: (t, e) => [
            { clipPath: t, easing: at },
            { clipPath: e, easing: at },
            { clipPath: t },
          ],
        };
      const nt = { top: "bottom", right: "left", bottom: "top", left: "right" };
      const ot = 40,
        st = {
          soft: { scaleFrom: 1.2, scaleTo: 0.8, travelY: 0 },
          medium: { scaleFrom: 1.7, scaleTo: 0.3, travelY: 0.5 },
          hard: { scaleFrom: 3.5, scaleTo: 0, travelY: 1 },
        },
        it = {
          top: [0, -50],
          "top-right": [50, -50],
          right: [50, 0],
          "bottom-right": [50, 50],
          bottom: [0, 50],
          "bottom-left": [-50, 50],
          left: [-50, 0],
          "top-left": [-50, -50],
          center: [0, 0],
        },
        ct = {
          in: (t, e, a) => ({
            fromValues: { scale: t, travel: a },
            toValues: { scale: 1, travel: 0 },
          }),
          out: (t, e, a) => ({
            fromValues: { scale: 1, travel: 0 },
            toValues: { scale: e, travel: -a },
          }),
          continuous: (t, e, a) => ({
            fromValues: { scale: t, travel: a },
            toValues: { scale: e, travel: -a },
          }),
        };
      const lt = {
          soft: { skewX: 10 },
          medium: { skewX: 17 },
          hard: { skewX: 24 },
        },
        ft = { right: -1, left: 1 },
        mt = {
          in: (t, e, a) => ({
            fromValues: { skewX: t, startX: e },
            toValues: { skewX: 0, endX: 0 },
          }),
          out: (t, e, a) => ({
            fromValues: { skewX: 0, startX: 0 },
            toValues: { skewX: -t, endX: e },
          }),
          continuous: (t, e, a) => ({
            fromValues: { skewX: t, startX: e },
            toValues: { skewX: -t, endX: a },
          }),
        },
        pt = {
          left: {
            startX: "calc(var(--motion-left, calc(100vw - 100%)) * -1 - 100%)",
            endX: "calc(100vw - var(--motion-left, 0px))",
          },
          right: {
            startX: "calc(100vw - var(--motion-left, 0px))",
            endX: "calc(var(--motion-left, calc(100vw - 100%)) * -1 - 100%)",
          },
        };
      const ut = ["bottom", "left", "top", "right"],
        dt = { top: "bottom", bottom: "top", left: "right", right: "left" },
        gt = {
          top: { x: "0", y: "-100%" },
          right: { x: "100%", y: "0" },
          bottom: { x: "0", y: "100%" },
          left: { x: "-100%", y: "0" },
        },
        yt = P({ direction: "initial" }),
        ht = {
          in: (t, e) => [
            {
              clipPath: `var(--motion-clip-from, ${t.from})`,
              transform: `rotate(var(--comp-rotate-z, 0)) translate(${e.from.x}, ${e.from.y})`,
            },
            {
              clipPath: yt,
              transform: "rotate(var(--comp-rotate-z, 0)) translate(0, 0)",
            },
          ],
          out: (t, e) => [
            {
              clipPath: yt,
              transform: "rotate(var(--comp-rotate-z, 0)) translate(0, 0)",
            },
            {
              clipPath: `var(--motion-clip-from, ${t.from})`,
              transform: `rotate(var(--comp-rotate-z, 0)) translate(${e.from.x}, ${e.from.y})`,
            },
          ],
          continuous: (t, e) => [
            {
              clipPath: `var(--motion-clip-from, ${t.from})`,
              transform: `rotate(var(--comp-rotate-z, 0)) translate(${e.from.x}, ${e.from.y})`,
            },
            {
              clipPath: yt,
              transform: "rotate(var(--comp-rotate-z, 0)) translate(0, 0)",
            },
            {
              clipPath: `var(--motion-clip-to, ${t.to})`,
              transform: `rotate(var(--comp-rotate-z, 0)) translate(${e.to.x}, ${e.to.y})`,
            },
          ],
        };
      const vt = 40,
        $t = {
          soft: { rotationZ: 45, travelY: 0 },
          medium: { rotationZ: 100, travelY: 0.5 },
          hard: { rotationZ: 200, travelY: 1 },
        },
        xt = {
          in: (t, e) => ({
            fromValues: {
              rotationX: -2 * t,
              rotationY: -t,
              rotationZ: -t,
              travel: e,
            },
            toValues: { rotationX: 0, rotationY: 0, rotationZ: 0, travel: 0 },
          }),
          out: (t, e) => ({
            fromValues: { rotationX: 0, rotationY: 0, rotationZ: 0, travel: 0 },
            toValues: {
              rotationX: 3 * t,
              rotationY: 2 * t,
              rotationZ: t,
              travel: -e,
            },
          }),
          continuous: (t, e) => ({
            fromValues: {
              rotationX: -2 * t,
              rotationY: -t,
              rotationZ: -t,
              travel: e,
            },
            toValues: {
              rotationX: 1.8 * t,
              rotationY: t,
              rotationZ: 2 * t,
              travel: -e,
            },
          }),
        };
      const bt = { soft: 1, medium: 0.7, hard: 0.4 },
        kt = { clockwise: 1, "counter-clockwise": -1 };
      const wt = {
          soft: { scaleY: 1.2, scaleX: 0.8 },
          medium: { scaleY: 1.5, scaleX: 0.6 },
          hard: { scaleY: 2, scaleX: 0.4 },
        },
        Et = {
          in: (t, e) => [
            { scale: `${t} ${e}`, translate: `0 ${100 * (e - 1)}%` },
            { scale: "1 1", translate: "0 0" },
          ],
          out: (t, e) => [
            { scale: "1 1", translate: "0 0" },
            { scale: `${t} ${e}`, translate: `0 ${100 * (1 - e)}%` },
          ],
          continuous: (t, e) => [
            {
              scale: `${t} ${e}`,
              translate: `0 ${100 * (e - 1)}%`,
              easing: O.backInOut,
            },
            { scale: "1 1", translate: "0 0", easing: O.backInOut },
            { scale: `${t} ${e}`, translate: `0 ${100 * (1 - e)}%` },
          ],
        },
        Yt = {
          in: [
            { opacity: 0, offset: 0 },
            { opacity: 1, offset: 0.65 },
          ],
          out: [
            { opacity: 1, offset: 0.35 },
            { opacity: 0, offset: 1 },
          ],
          continuous: [
            { opacity: 0, offset: 0 },
            { opacity: 1, offset: 0.325 },
            { opacity: 1, offset: 0.7 },
            { opacity: 0, offset: 1 },
          ],
        };
      const Ot = 40,
        [It, Pt, zt] = [10, 25, 25],
        [Xt, _t, St] = [-1, 1, 0],
        Tt = { soft: 0, medium: 0.5, hard: 1 },
        Mt = { right: 1, left: -1 },
        At = {
          in: {
            from: { x: -1, y: -1, z: 1, transY: _t },
            to: { x: 0, y: 0, z: 0, transY: St },
          },
          out: {
            from: { x: 0, y: 0, z: 0, transY: St },
            to: { x: -1, y: -1, z: 1, transY: Xt },
          },
          continuous: {
            from: { x: -1, y: -1, z: -1, transY: _t },
            to: { x: 1, y: 0.5, z: 1.25, transY: Xt },
          },
        };
      function Bt(t, e) {
        return (e && e in Tt ? Tt[e] : t) * Ot;
      }
      const Vt = {
          soft: { scaleFrom: 1, scaleTo: 1 },
          medium: { scaleFrom: 0.7, scaleTo: 1.3 },
          hard: { scaleFrom: 0.4, scaleTo: 1.6 },
        },
        Zt = { clockwise: 1, "counter-clockwise": -1 },
        Rt = {
          left: {
            startX: "calc(-1 * var(--motion-left, calc(100vw - 100%)) - 100%)",
            endX: "calc(100vw - var(--motion-left, 0px))",
          },
          right: {
            startX: "calc(100vw - var(--motion-left, 0px))",
            endX: "calc(-1 * var(--motion-left, calc(100vw - 100%)) - 100%)",
          },
        },
        Ct = {
          in: (t, e, a) => ({
            fromValues: {
              rotation: -t,
              scale: e.scaleFrom,
              translate: a.startX,
            },
            toValues: { rotation: 0, scale: 1, translate: "0px" },
          }),
          out: (t, e, a) => ({
            fromValues: { rotation: 0, scale: 1, translate: "0px" },
            toValues: { rotation: t, scale: e.scaleFrom, translate: a.endX },
          }),
          continuous: (t, e, a) => ({
            fromValues: {
              rotation: -t,
              scale: e.scaleFrom,
              translate: a.startX,
            },
            toValues: { rotation: t, scale: e.scaleTo, translate: a.endX },
          }),
        };
      const Ft = {
          ArcScroll: function (t) {
            const { direction: e = "horizontal", range: a = "in" } =
                t.namedEffect,
              r = "out" === a ? "forwards" : "in" === a ? "backwards" : t.fill,
              n = y[e],
              { fromValue: o, toValue: s } = h[a];
            return [
              {
                ...t,
                fill: r,
                easing: "linear",
                keyframes: [
                  {
                    transform: `perspective(500px) translateZ(-300px)  ${n}(${o}deg) translateZ(300px) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                  {
                    transform: `perspective(500px) translateZ(-300px) ${n}(${s}deg) translateZ(300px) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                ],
              },
            ];
          },
          BlurScroll: function (t) {
            const { blur: e = 6, power: a, range: r = "in" } = t.namedEffect,
              n = a && v[a] ? v[a] : e,
              o = "out" === r ? 0 : n,
              s = "out" === r ? n : 0,
              i = "out" === r ? "forwards" : "in" === r ? "backwards" : t.fill;
            return [
              {
                ...t,
                fill: i,
                easing: "linear",
                composite: "add",
                keyframes: [
                  { filter: `blur(${o}px)` },
                  { filter: `blur(${s}px)` },
                ],
              },
            ];
          },
          FadeScroll: function (t) {
            const { opacity: e = 0, range: a = "in" } = t.namedEffect,
              r = "out" === a,
              n = r ? "var(--comp-opacity, 1)" : e,
              o = r ? e : "var(--comp-opacity, 1)",
              s = "out" === a ? "forwards" : "in" === a ? "backwards" : t.fill;
            return [
              {
                ...t,
                fill: s,
                easing: "linear",
                keyframes: [{ opacity: n }, { opacity: o }],
              },
            ];
          },
          FlipScroll: function (t) {
            const {
                rotate: e = 240,
                direction: a = "horizontal",
                power: r,
                range: n = "continuous",
              } = t.namedEffect,
              o = x[a],
              s = r && $[r] ? $[r] : e,
              i = "out" === n ? 0 : -s,
              c = "in" === n ? 0 : s,
              l = "out" === n ? "forwards" : "in" === n ? "backwards" : t.fill;
            return [
              {
                ...t,
                fill: l,
                easing: "linear",
                keyframes: [
                  {
                    transform: `perspective(800px) ${o}(${i}deg) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                  {
                    transform: `perspective(800px) ${o}(${c}deg) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                ],
              },
            ];
          },
          GrowScroll: function (t) {
            const {
                power: e,
                range: a = "in",
                scale: r = "in" === a ? k.hard.scaleFrom : k.hard.scaleTo,
                direction: n = "center",
                speed: o = 0,
              } = t.namedEffect,
              s = "out" === a ? "forwards" : "in" === a ? "backwards" : t.fill,
              {
                scaleFrom: i,
                scaleTo: c,
                travelY: l,
              } = e && k[e] ? k[e] : { scaleFrom: r, scaleTo: r, travelY: o },
              { fromValues: f, toValues: m } = E[a](i, c, l * -b),
              { start: p, end: u } = (function (t) {
                let { power: e, range: a = "in", speed: r = 0 } = t;
                const n = e && k[e] ? k[e].travelY : Math.abs(r) * b;
                return {
                  start: "out" === a ? "0px" : -n + "vh",
                  end: "in" === a ? "0px" : `${n}vh`,
                };
              })(t.namedEffect),
              [d, g] = w[n];
            return [
              {
                ...t,
                fill: s,
                easing: "linear",
                startOffsetAdd: p,
                endOffsetAdd: u,
                keyframes: [
                  {
                    transform: `translateY(${
                      f.travel
                    }vh) translate(${d}%, ${g}%) scale(${
                      f.scale
                    }) translate(${-d}%, ${-g}%) rotate(var(--comp-rotate-z, 0))`,
                  },
                  {
                    transform: `translateY(${
                      m.travel
                    }vh) translate(${d}%, ${g}%) scale(${
                      m.scale
                    }) translate(${-d}%, ${-g}%) rotate(var(--comp-rotate-z, 0))`,
                  },
                ],
              },
            ];
          },
          MoveScroll: function (t) {
            const {
                power: e,
                distance: a = { value: 400, type: "px" },
                angle: r = 210,
                range: n = "in",
              } = t.namedEffect,
              o = e ? G[e] : a,
              [s, i] = X(r - 90, o.value),
              { fromValue: c, toValue: l } = q[n](Math.round(s), Math.round(i)),
              f = _(o.type),
              m = "out" === n ? "forwards" : "in" === n ? "backwards" : t.fill,
              { start: p, end: u } = (function (t) {
                let {
                  angle: e = 210,
                  distance: a = { value: 400, type: "px" },
                  power: r,
                  range: n = "in",
                } = t;
                const o = r ? G[r] : a,
                  [, s] = X(e - 90, o.value),
                  i = (s < 0 && "out" !== n) || (s > 0 && "out" === n),
                  c = _(o.type),
                  l = i ? `${s}${c}` : "0px",
                  f = i ? `${Math.abs(s)}${c}` : "0px";
                return {
                  start: "out" === n ? "0px" : l,
                  end: "in" === n ? "0px" : f,
                };
              })(t.namedEffect);
            return [
              {
                ...t,
                fill: m,
                easing: "linear",
                startOffsetAdd: p,
                endOffsetAdd: u,
                keyframes: [
                  {
                    transform: `translate(${c.x}${f}, ${c.y}${f}) rotate(var(--comp-rotate-z, 0))`,
                  },
                  {
                    transform: `translate(${l.x}${f}, ${l.y}${f}) rotate(var(--comp-rotate-z, 0))`,
                  },
                ],
              },
            ];
          },
          PanScroll: function (t, e) {
            const {
                distance: a = { value: 400, type: "px" },
                direction: r = "left",
                startFromOffScreen: n = !0,
                range: o = "in",
              } = t.namedEffect,
              s = a.value * H[r],
              { startX: i, endX: c } = n
                ? W[r]
                : { startX: `${-s}${_(a.type)}`, endX: `${s}${_(a.type)}` },
              l = "out" === o ? 0 : i,
              f = "in" === o ? 0 : "out" === o ? i : c,
              m = "out" === o ? "forwards" : "in" === o ? "backwards" : t.fill;
            if (n && e) {
              let t = 0;
              e.measure((e) => {
                e && (t = e.getBoundingClientRect().left);
              }),
                e.mutate((e) => {
                  null == e || e.style.setProperty("--motion-left", `${t}px`);
                });
            }
            return [
              {
                ...t,
                fill: m,
                easing: "linear",
                keyframes: [
                  {
                    transform: `translateX(${l}) rotate(var(--comp-rotate-z, 0))`,
                  },
                  {
                    transform: `translateX(${f}) rotate(var(--comp-rotate-z, 0))`,
                  },
                ],
              },
            ];
          },
          ParallaxScroll: function (t) {
            const { speed: e = L } = t.namedEffect,
              a = -50 * e + "vh",
              r = 50 * e + "vh",
              { start: n, end: o } = (function (t) {
                let { speed: e = L } = t;
                return { start: U(-0.5, e), end: U(0.5, e) };
              })(t.namedEffect);
            return [
              {
                ...t,
                fill: "both",
                easing: "linear",
                startOffsetAdd: n,
                endOffsetAdd: o,
                keyframes: [
                  {
                    transform: `translateY(${a}) rotate(var(--comp-rotate-z, 0))`,
                  },
                  {
                    transform: `translateY(${r}) rotate(var(--comp-rotate-z, 0))`,
                  },
                ],
              },
            ];
          },
          RevealScroll: function (t, e) {
            const { direction: a = "bottom", range: r = "in" } = t.namedEffect,
              n = "out" === r ? "forwards" : "in" === r ? "backwards" : t.fill;
            let o = N(a, r),
              s = Q(a, r);
            e &&
              e.measure((t) => {
                if (!t) return;
                const n =
                  getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                  "0";
                e.mutate(() => {
                  const e = z(j, a, parseInt(n, 10));
                  (o = N(e, r)),
                    (s = Q(e, r)),
                    t.style.setProperty("--motion-clip-from", o),
                    t.style.setProperty("--motion-clip-to", s);
                });
              });
            const i =
              "continuous" === r
                ? [
                    { clipPath: `var(--motion-clip-from, ${o})` },
                    { clipPath: K },
                    { clipPath: `var(--motion-clip-to, ${s})` },
                  ]
                : [
                    { clipPath: `var(--motion-clip-from, ${o})` },
                    { clipPath: `var(--motion-clip-to, ${s})` },
                  ];
            return [{ ...t, fill: n, easing: "linear", keyframes: i }];
          },
          ShapeScroll: function (t) {
            const {
                shape: e = "circle",
                power: a,
                intensity: r = 0.5,
                range: n = "in",
              } = t.namedEffect,
              o = "out" === n ? "forwards" : "in" === n ? "backwards" : t.fill,
              [s, i] =
                a && tt[e].start[a]
                  ? [tt[e].start[a], tt[e].end]
                  : et[e](100 * r),
              c = rt[n](s, i);
            return [{ ...t, fill: o, easing: "linear", keyframes: c }];
          },
          ShuttersScroll: function (t) {
            const {
                direction: e = "right",
                shutters: a = 12,
                staggered: r = !0,
                range: n = "in",
              } = t.namedEffect,
              o = "out" === n ? "forwards" : "in" === n ? "backwards" : t.fill,
              s = S("sineIn"),
              i = nt[e],
              { clipStart: c, clipEnd: l } = D("out" === n ? i : e, a, r),
              f = "out" !== n ? c : l,
              m = "out" !== n ? l : c;
            let p;
            if ("continuous" === n) {
              const { clipStart: t, clipEnd: e } = D(i, a, r, !0);
              p = [
                { clipPath: f, easing: s },
                { clipPath: m, offset: r ? 0.45 : 0.4, easing: s },
                { clipPath: m, offset: r ? 0.55 : 0.6, easing: s },
                { clipPath: e, offset: r ? 0.55 : 0.6, easing: s },
                { clipPath: t },
              ];
            } else p = [{ clipPath: f, easing: s }, { clipPath: m }];
            return [{ ...t, fill: o, easing: "linear", keyframes: p }];
          },
          ShrinkScroll: function (t) {
            const {
                power: e,
                range: a = "in",
                scale: r = "in" === a ? 1.2 : 0.8,
                direction: n = "center",
                speed: o = 0,
              } = t.namedEffect,
              s = "out" === a ? "forwards" : "in" === a ? "backwards" : t.fill,
              {
                scaleFrom: i,
                scaleTo: c,
                travelY: l,
              } = e && st[e] ? st[e] : { scaleFrom: r, scaleTo: r, travelY: o },
              { fromValues: f, toValues: m } = ct[a](i, c, l * -ot),
              { start: p, end: u } = (function (t) {
                let { power: e, range: a = "in", speed: r = 0 } = t;
                const n = e && st[e] ? st[e].travelY : Math.abs(r) * ot;
                return {
                  start: "out" === a ? "0px" : -n + "vh",
                  end: "in" === a ? "0px" : `${n}vh`,
                };
              })(t.namedEffect),
              [d, g] = it[n];
            return [
              {
                ...t,
                fill: s,
                easing: "linear",
                startOffsetAdd: p,
                endOffsetAdd: u,
                keyframes: [
                  {
                    transform: `translateY(${
                      f.travel
                    }vh) translate(${d}%, ${g}%) scale(${
                      f.scale
                    }) translate(${-d}%, ${-g}%) rotate(var(--comp-rotate-z, 0))`,
                  },
                  {
                    transform: `translateY(${
                      m.travel
                    }vh) translate(${d}%, ${g}%) scale(${
                      m.scale
                    }) translate(${-d}%, ${-g}%) rotate(var(--comp-rotate-z, 0))`,
                  },
                ],
              },
            ];
          },
          SkewPanScroll: function (t, e) {
            const {
                skew: a = 10,
                direction: r = "right",
                power: n,
                range: o = "in",
              } = t.namedEffect,
              s = "out" === o ? "forwards" : "in" === o ? "backwards" : t.fill,
              i = (n && lt[n] ? lt[n].skewX : a) * ft[r],
              { startX: c, endX: l } = pt[r],
              { fromValues: f, toValues: m } = mt[o](i, c, l);
            let p = 0;
            return (
              e &&
                (e.measure((t) => {
                  t && (p = t.getBoundingClientRect().left);
                }),
                e.mutate((t) => {
                  null == t || t.style.setProperty("--motion-left", `${p}px`);
                })),
              [
                {
                  ...t,
                  fill: s,
                  easing: "linear",
                  keyframes: [
                    {
                      transform: `translateX(${f.startX}) skewX(${f.skewX}deg) rotate(var(--comp-rotate-z, 0))`,
                    },
                    {
                      transform: `translateX(${m.endX}) skewX(${m.skewX}deg) rotate(var(--comp-rotate-z, 0))`,
                    },
                  ],
                },
              ]
            );
          },
          SlideScroll: function (t, e) {
            const { direction: a = "bottom", range: r = "in" } = t.namedEffect,
              n = "out" === r ? "forwards" : "in" === r ? "backwards" : t.fill,
              o = dt[a],
              s = ht[r](
                { from: P({ direction: o }), to: P({ direction: a }) },
                { from: gt[a], to: gt[o] }
              );
            return (
              e &&
                e.measure((t) => {
                  if (!t) return;
                  const r = parseInt(
                    getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                      "0",
                    10
                  );
                  e.mutate(() => {
                    const e = z(ut, a, r);
                    t.style.setProperty(
                      "--motion-clip-from",
                      P({ direction: dt[e] })
                    ),
                      t.style.setProperty(
                        "--motion-clip-to",
                        P({ direction: e })
                      );
                  });
                }),
              [{ ...t, fill: n, easing: "linear", keyframes: s }]
            );
          },
          Spin3dScroll: function (t) {
            const {
                rotate: e = -100,
                power: a,
                range: r = "in",
                speed: n = 0,
              } = t.namedEffect,
              o = "out" === r ? "forwards" : "in" === r ? "backwards" : t.fill,
              s = a && $t[a] ? $t[a] : { rotationZ: e, travelY: n },
              { fromValues: i, toValues: c } = xt[r](
                s.rotationZ,
                s.travelY * -vt
              ),
              { start: l, end: f } = (function (t) {
                let { power: e, range: a = "in", speed: r = 0 } = t;
                const n = (e && $t[e] ? $t[e].travelY : Math.abs(r)) * vt;
                return {
                  start: "out" === a ? "0px" : -n + "vh",
                  end: "in" === a ? "0px" : `${n}vh`,
                };
              })(t.namedEffect);
            return [
              {
                ...t,
                fill: o,
                easing: "linear",
                startOffsetAdd: l,
                endOffsetAdd: f,
                keyframes: [
                  {
                    transform: `perspective(1000px) translateY(${i.travel}vh) rotateZ(calc(var(--comp-rotate-z, 0deg) + ${i.rotationZ}deg)) rotateY(${i.rotationY}deg) rotateX(${i.rotationX}deg)`,
                  },
                  {
                    transform: `perspective(1000px) translateY(${c.travel}vh) rotateZ(calc(var(--comp-rotate-z, 0deg) + ${c.rotationZ}deg)) rotateY(${c.rotationY}deg) rotateX(${c.rotationX}deg)`,
                  },
                ],
              },
            ];
          },
          SpinScroll: function (t) {
            const {
                spins: e = 0.15,
                scale: a = 1,
                direction: r = "clockwise",
                power: n,
                range: o = "in",
              } = t.namedEffect,
              s = "out" === o ? "forwards" : "in" === o ? "backwards" : t.fill,
              i = kt[r],
              c = 360 * e,
              l = n && bt[n] ? bt[n] : a,
              f = "in" === o,
              m = f ? -c : "out" === o ? 0 : -c / 2,
              p = f ? 0 : "out" === o ? c : c / 2;
            return [
              {
                ...t,
                fill: s,
                easing: "linear",
                keyframes: [
                  {
                    transform: `scale(${
                      f ? l : 1
                    }) rotate(calc(var(--comp-rotate-z, 0deg) + ${m * i}deg))`,
                  },
                  {
                    transform: `scale(${
                      f ? 1 : l
                    }) rotate(calc(var(--comp-rotate-z, 0deg) + ${p * i}deg))`,
                  },
                ],
              },
            ];
          },
          StretchScroll: function (t) {
            const {
                power: e,
                stretch: a = 0.6,
                range: r = "out",
              } = t.namedEffect,
              n = "continuous" === r ? "linear" : "backInOut",
              o = "out" === r ? "forwards" : "in" === r ? "backwards" : t.fill,
              { scaleX: s, scaleY: i } =
                e && wt[e] ? wt[e] : { scaleX: 1 - a, scaleY: 1 + a },
              c = Et[r](s, i);
            return [
              { ...t, fill: o, easing: n, keyframes: c },
              { ...t, fill: o, easing: n, keyframes: Yt[r] },
            ];
          },
          TiltScroll: function (t) {
            const {
                power: e,
                distance: a = 0,
                range: r = "in",
                direction: n = "right",
              } = t.namedEffect,
              o = "out" === r ? "forwards" : "in" === r ? "backwards" : t.fill,
              { from: s, to: i } = At[r],
              c = Mt[n],
              l = Math.abs(s.z) * zt * c * (s.z < 0 ? -1 : 1),
              f = Math.abs(i.z) * zt * c * (i.z < 0 ? -1 : 1),
              m = Bt(a, e),
              p = m * s.transY,
              u = m * i.transY,
              d = s.x * It,
              g = s.y * Pt,
              y = i.x * It,
              h = i.y * Pt,
              { start: v, end: $ } = (function (t) {
                let { power: e, range: a = "in", distance: r = 0 } = t;
                const n = Math.abs(Bt(r, e));
                return {
                  start: "out" === a ? "0px" : -n + "vh",
                  end: "in" === a ? "0px" : `${n}vh`,
                };
              })(t.namedEffect);
            return [
              {
                ...t,
                fill: o,
                easing: "linear",
                startOffsetAdd: v,
                endOffsetAdd: $,
                keyframes: [
                  {
                    transform: `perspective(400px) translateY(${p}vh) rotateX(${d}deg) rotateY(${g}deg)`,
                  },
                  {
                    transform: `perspective(400px) translateY(${u}vh) rotateX(${y}deg) rotateY(${h}deg)`,
                  },
                ],
              },
              {
                ...t,
                fill: o,
                easing: O.sineInOut,
                startOffsetAdd: v,
                endOffsetAdd: $,
                composite: "add",
                keyframes: [
                  {
                    transform: `rotate(calc(var(--comp-rotate-z, 0deg) + ${l}deg))`,
                  },
                  {
                    transform: `rotate(calc(var(--comp-rotate-z, 0deg) + ${f}deg))`,
                  },
                ],
              },
            ];
          },
          TurnScroll: function (t, e) {
            const {
                power: a,
                spin: r = "clockwise",
                direction: n = "right",
                scale: o = 1,
                range: s = "in",
              } = t.namedEffect,
              i = "out" === s ? "forwards" : "in" === s ? "backwards" : t.fill,
              c = Rt[n],
              l = 45 * Zt[r],
              f = a && Vt[a] ? Vt[a] : { scaleFrom: o, scaleTo: o },
              { fromValues: m, toValues: p } = Ct[s](l, f, c);
            let u = 0;
            return (
              e &&
                (e.measure((t) => {
                  t && (u = t.getBoundingClientRect().left);
                }),
                e.mutate((t) => {
                  null == t || t.style.setProperty("--motion-left", `${u}px`);
                })),
              [
                {
                  ...t,
                  fill: i,
                  easing: "linear",
                  keyframes: [
                    {
                      transform: `translateX(${m.translate}) scale(${m.scale}) rotate(calc(var(--comp-rotate-z, 0deg) + ${m.rotation}deg))`,
                    },
                    {
                      transform: `translateX(${p.translate}) scale(${p.scale}) rotate(calc(var(--comp-rotate-z, 0deg) + ${p.rotation}deg))`,
                    },
                  ],
                },
              ]
            );
          },
        },
        Dt = {
          top: { rotateX: "80deg" },
          right: { rotateY: "80deg" },
          bottom: { rotateX: "-80deg" },
          left: { rotateY: "-80deg" },
        },
        Gt = { soft: "cubicInOut", medium: "quintInOut", hard: "backOut" };
      const qt = { soft: 6, medium: 25, hard: 50 };
      const { in: Ht, out: Wt } = T("sine"),
        Lt = [
          { offset: 0, translate: 100, ease: Ht },
          { offset: 30, translate: 0, ease: Wt },
          { offset: 42, translate: 35, ease: Ht },
          { offset: 54, translate: 0, ease: Wt },
          { offset: 62, translate: 21, ease: Ht },
          { offset: 74, translate: 0, ease: Wt },
          { offset: 82, translate: 9, ease: Ht },
          { offset: 90, translate: 0, ease: Wt },
          { offset: 95, translate: 2, ease: Ht },
          { offset: 100, translate: 0, ease: Wt },
        ],
        Ut = { soft: 1, medium: 2, hard: 3 },
        jt = {
          top: { y: -1, x: 0, z: 0 },
          right: { y: 0, x: 1, z: 0 },
          bottom: { y: 1, x: 0, z: 0 },
          left: { y: 0, x: -1, z: 0 },
          center: { x: 0, y: 0, z: -1 },
        };
      const Jt = {
        pseudoRight: { rotationX: "180", rotationY: "0" },
        right: { rotationX: "0", rotationY: "180" },
        pseudoLeft: { rotationX: "-180", rotationY: "0" },
        left: { rotationX: "0", rotationY: "-180" },
      };
      const Kt = {
        soft: { scale: 1.2, ease: "cubicInOut" },
        medium: { scale: 1.6, ease: "quintInOut" },
        hard: { scale: 2, ease: "backOut" },
      };
      const Nt = { soft: 0.8, medium: 0.6, hard: 0 },
        Qt = {
          top: { x: 0, y: -0.5 },
          "top-right": { x: 0.5, y: -0.5 },
          right: { x: 0.5, y: 0 },
          "bottom-right": { x: 0.5, y: 0.5 },
          bottom: { x: 0, y: 0.5 },
          "bottom-left": { x: -0.5, y: 0.5 },
          left: { x: -0.5, y: 0 },
          "top-left": { x: -0.5, y: -0.5 },
          center: { x: 0, y: 0 },
        };
      const te = ["top", "right", "bottom", "left"],
        ee = { soft: 45, medium: 90, hard: 270 };
      function ae(t, e) {
        return { x: re[t].x * e, y: re[t].y * e };
      }
      const re = {
        top: { x: 1, y: 0 },
        right: { x: 0, y: 1 },
        bottom: { x: -1, y: 0 },
        left: { x: 0, y: -1 },
      };
      const ne = {
        top: { dx: 0, dy: -1, distance: 120 },
        right: { dx: 1, dy: 0, distance: 120 },
        bottom: { dx: 0, dy: 1, distance: 120 },
        left: { dx: -1, dy: 0, distance: 120 },
      };
      const oe = { soft: 35, medium: 60, hard: 90 },
        se = ["top", "right", "bottom", "left"],
        ie = {
          top: { x: -1, y: 0, origin: { x: 0, y: -50 } },
          right: { x: 0, y: -1, origin: { x: 50, y: 0 } },
          bottom: { x: 1, y: 0, origin: { x: 0, y: 50 } },
          left: { x: 0, y: 1, origin: { x: -50, y: 0 } },
        };
      function ce(t, e) {
        return { x: ie[t].x * e, y: ie[t].y * e };
      }
      const le = { soft: "cubicInOut", medium: "quintInOut", hard: "backOut" };
      const fe = { soft: "cubicInOut", medium: "quintInOut", hard: "backOut" };
      const me = { soft: 0.8, medium: 0.6, hard: 0 };
      const pe = {
          "top-left": { y: -1, x: -1 },
          "top-right": { y: -1, x: 1 },
          "bottom-right": { y: 1, x: 1 },
          "bottom-left": { y: 1, x: -1 },
          center: { y: 0, x: 0 },
        },
        ue = { soft: "sine", medium: "quad", hard: "quint" };
      const de = {
        diamond: {
          start: "polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%)",
          end: "polygon(50% -50%, 150% 50%, 50% 150%, -50% 50%)",
        },
        window: {
          start: "inset(50% round 50% 50% 0% 0%)",
          end: "inset(-20% round 50% 50% 0% 0%)",
        },
        rectangle: { start: "inset(50%)", end: "inset(0%)" },
        circle: { start: "circle(0%)", end: "circle(75%)" },
        ellipse: { start: "ellipse(0% 0%)", end: "ellipse(75% 75%)" },
      };
      const ge = ["top", "right", "bottom", "left"];
      function ye(t, e) {
        return P({ direction: z(ge, e, t), minimum: 0 });
      }
      const he = {
          top: { dx: 0, dy: -1, clip: "bottom" },
          right: { dx: 1, dy: 0, clip: "left" },
          bottom: { dx: 0, dy: 1, clip: "top" },
          left: { dx: -1, dy: 0, clip: "right" },
        },
        ve = ["top", "right", "bottom", "left"],
        $e = { soft: 0.2, medium: 0.8, hard: 1 };
      const xe = { soft: 1, medium: 0.6, hard: 0 },
        be = { clockwise: -1, "counter-clockwise": 1 };
      const ke = { left: 30, right: -30 },
        we = ["top", "right", "bottom", "left"];
      function Ee(t) {
        return P({ direction: z(we, "top", t), minimum: 0 });
      }
      const Ye = { soft: "cubicInOut", medium: "quintInOut", hard: "backOut" },
        Oe = {
          "top-left": { angle: -50, x: -50, y: -50 },
          "top-right": { angle: 50, x: 50, y: -50 },
          "bottom-right": { angle: 50, x: 50, y: 50 },
          "bottom-left": { angle: -50, x: -50, y: 50 },
        };
      const Ie = {
          vertical: { scaleY: 0, scaleX: 1 },
          horizontal: { scaleY: 1, scaleX: 0 },
        },
        Pe = ["vertical", "horizontal"];
      const ze = {
        ArcIn: function (t, e) {
          const { direction: a = "right", power: r } = t.namedEffect,
            n = (r && Gt[r]) || t.easing || "quintInOut",
            { rotateX: o, rotateY: s } = Dt[a],
            i = `calc(-1 * var(${
              o ? "--motion-height" : "--motion-width"
            }, 100v${o ? "h" : "w"}) / 2)`;
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const { width: a, height: r } = t.getBoundingClientRect();
                e.mutate(() => {
                  o
                    ? t.style.setProperty("--motion-height", `${r}px`)
                    : t.style.setProperty("--motion-width", `${a}px`);
                });
              }),
            [
              {
                ...t,
                duration: 0.7 * t.duration,
                easing: "sineIn",
                keyframes: [
                  { opacity: 0 },
                  { opacity: "var(--comp-opacity, 1)" },
                ],
              },
              {
                ...t,
                easing: n,
                keyframes: [
                  {
                    transform: `perspective(800px) translateZ(${i}) ${
                      o ? "rotateX" : "rotateY"
                    }(${
                      o || s
                    }) translateZ(calc(-1 * ${i})) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                  {
                    transform: `perspective(800px) translateZ(${i}) ${
                      o ? "rotateX" : "rotateY"
                    }(0deg) translateZ(calc(-1 * ${i})) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                ],
              },
            ]
          );
        },
        BlurIn: function (t) {
          const { blur: e = 6, power: a } = t.namedEffect,
            r = t.easing || "linear",
            n = a && qt[a] ? qt[a] : e;
          return [
            {
              ...t,
              duration: 0.7 * t.duration,
              easing: "sineIn",
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
            {
              ...t,
              easing: r,
              composite: "add",
              keyframes: [{ filter: `blur(${n}px)` }, { filter: "blur(0px)" }],
            },
          ];
        },
        ShuttersIn: function (t) {
          const {
              direction: e = "right",
              shutters: a = 12,
              staggered: r = !0,
            } = t.namedEffect,
            n = S(t.easing || "sineIn"),
            { clipStart: o, clipEnd: s } = D(e, a, r);
          return [
            { ...t, easing: n, keyframes: [{ clipPath: o }, { clipPath: s }] },
          ];
        },
        BounceIn: function (t) {
          const {
              power: e,
              distanceFactor: a = 1,
              direction: r = "bottom",
            } = t.namedEffect,
            n = t.duration,
            o = (e && Ut[e]) || a,
            { x: s, y: i, z: c } = jt[r],
            l = "center" === r ? "perspective(800px) " : "",
            f = Lt.map((t) => {
              let { offset: e, translate: a, ease: r } = t;
              return {
                offset: e / 100,
                animationTimingFunction: S(r),
                transform: `${l}translate3d(${(s * a * o) / 2}px, ${
                  (i * a * o) / 2
                }px, ${
                  (c * a * o) / 2
                }px)  rotateZ(var(--comp-rotate-z, 0deg))`,
              };
            });
          return [
            {
              ...t,
              duration: (n * Lt[3].offset) / 100,
              easing: "quadOut",
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
            { ...t, keyframes: f },
          ];
        },
        CurveIn: function (t, e) {
          const { direction: a = "right" } = t.namedEffect,
            { rotationX: r, rotationY: n } = Jt[a];
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const a = t.getBoundingClientRect().width;
                e.mutate((t) => {
                  null == t || t.style.setProperty("--motion-width", `${a}px`);
                });
              }),
            [
              {
                ...t,
                easing: "quadOut",
                keyframes: [
                  {
                    opacity: 0,
                    transform: `perspective(200px) translateZ(calc(var(--motion-width, 300px) * -3)) rotateX(${r}deg) rotateY(${n}deg) translateZ(calc(var(--motion-width, 300px) * 3)) rotateZ(var(--comp-rotate-z, 0deg))`,
                  },
                  {
                    opacity: "var(--comp-opacity, 1)",
                    transform:
                      "perspective(200px) translateZ(calc(var(--motion-width, 300px) * -3)) rotateX(0deg) rotateY(0deg) translateZ(calc(var(--motion-width, 300px) * 3)) rotateZ(var(--comp-rotate-z, 0deg))",
                  },
                ],
              },
            ]
          );
        },
        CircleIn: function (t, e) {
          const { direction: a = "right" } = t.namedEffect,
            r =
              "right" === a
                ? "calc(100vw - var(--motion-left, 0px))"
                : "calc(var(--motion-left, calc(100vw - 100%)) * -1 - 100%)";
          if (e) {
            let t = 0;
            e.measure((e) => {
              e && (t = e.getBoundingClientRect().left);
            }),
              e.mutate((e) => {
                null == e || e.style.setProperty("--motion-left", `${t}px`);
              });
          }
          return [
            {
              ...t,
              easing: "circOut",
              keyframes: [{ translate: r }, { translate: "0" }],
            },
            {
              ...t,
              easing: "linear",
              keyframes: [
                {
                  opacity: 0,
                  transform: `translateY(min(calc(100% * -1.5), max(-300px, calc(100% * -5.5)))) rotate(calc(var(--comp-rotate-z, 0deg) ${
                    "right" === a ? "+" : "-"
                  } 45deg))`,
                },
                {
                  opacity: "var(--comp-opacity, 1)",
                  transform: "translateY(0) rotate(var(--comp-rotate-z, 0deg))",
                },
              ],
            },
          ];
        },
        DropIn: function (t) {
          const { power: e, initialScale: a = Kt.medium.scale } = t.namedEffect,
            r = (e && Kt[e].scale) || a,
            n = (e && Kt[e].ease) || t.easing || "quintInOut";
          return [
            {
              ...t,
              easing: "quadOut",
              duration: 0.8 * t.duration,
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
            { ...t, easing: n, keyframes: [{ scale: `${r}` }, { scale: "1" }] },
          ];
        },
        ExpandIn: function (t, e) {
          const {
              power: a,
              initialScale: r = 0,
              direction: n = "center",
            } = t.namedEffect,
            o = t.easing || "cubicInOut",
            s = a && a in Nt ? Nt[a] : r,
            { x: i, y: c } = Qt[n];
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const { width: a, height: r } = t.getBoundingClientRect();
                e.mutate(() => {
                  t.style.setProperty("--motion-width", `${a}px`),
                    t.style.setProperty("--motion-height", `${r}px`);
                });
              }),
            [
              {
                ...t,
                easing: "linear",
                keyframes: [
                  { opacity: 0 },
                  { opacity: "var(--comp-opacity, 1)" },
                ],
              },
              {
                ...t,
                easing: o,
                keyframes: [
                  {
                    transform: `translateX(calc(var(--motion-width, 100%) * ${i})) translateY(calc(var(--motion-height, 100%) * ${c})) scale(${s}) translateX(calc(var(--motion-width, 100%) * ${-i})) translateY(calc(var(--motion-height, 100%) * ${-c}))  rotate(var(--comp-rotate-z, 0deg))`,
                  },
                  {
                    transform: `translateX(calc(var(--motion-width, 100%) * ${i})) translateY(calc(var(--motion-height, 100%) * ${c})) scale(1) translateX(calc(var(--motion-width, 100%) * ${-i})) translateY(calc(var(--motion-height, 100%) * ${-c})) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                ],
              },
            ]
          );
        },
        FadeIn: function (t) {
          return [
            {
              ...t,
              easing: "sineInOut",
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
          ];
        },
        FlipIn: function (t, e) {
          const {
              direction: a = "top",
              power: r,
              initialRotate: n = 90,
            } = t.namedEffect,
            o = t.easing || "backOut",
            s = (r && ee[r]) || n;
          let i = ae(a, s);
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const r =
                    getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                    "0deg",
                  n = z(te, a, parseInt(r, 10));
                e.mutate(() => {
                  (i = ae(n, s)),
                    t.style.setProperty("--motion-rotate-x", `${i.x}deg`),
                    t.style.setProperty("--motion-rotate-y", `${i.y}deg`);
                });
              }),
            [
              {
                ...t,
                easing: "quadOut",
                keyframes: [
                  { opacity: 0 },
                  { opacity: "var(--comp-opacity, 1)" },
                ],
              },
              {
                ...t,
                easing: o,
                keyframes: [
                  {
                    transform: `perspective(800px) rotate(var(--comp-rotate-z, 0deg)) rotateX(var(--motion-rotate-x , ${i.x}deg)) rotateY(var(--motion-rotate-y , ${i.y}deg))`,
                  },
                  {
                    transform:
                      "perspective(800px) rotate(var(--comp-rotate-z, 0deg)) rotateX(0deg) rotateY(0deg)",
                  },
                ],
              },
            ]
          );
        },
        FloatIn: function (t) {
          const { direction: e = "left" } = t.namedEffect,
            a = ne[e],
            r = a.dx * a.distance,
            n = a.dy * a.distance;
          return [
            {
              ...t,
              easing: "sineInOut",
              duration: t.duration,
              keyframes: [
                { opacity: 0, translate: `${r}px ${n}px` },
                { opacity: "var(--comp-opacity, 1)", translate: "0px 0px" },
              ],
            },
          ];
        },
        FoldIn: function (t, e) {
          const {
              direction: a = "top",
              power: r,
              initialRotate: n = 90,
            } = t.namedEffect,
            o = t.easing || "backOut",
            s = (r && oe[r]) || n,
            { x: i, y: c } = ie[a].origin,
            l = ce(a, s);
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const r =
                    getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                    "0deg",
                  n = z(se, a, parseInt(r, 10));
                e.mutate(() => {
                  const { origin: e } = ie[n],
                    a = ce(n, s);
                  null == t ||
                    t.style.setProperty("--motion-origin-x", `${e.x}%`),
                    null == t ||
                      t.style.setProperty("--motion-origin-y", `${e.y}%`),
                    null == t ||
                      t.style.setProperty("--motion-rotate-x", `${a.x}deg`),
                    null == t ||
                      t.style.setProperty("--motion-rotate-y", `${a.y}deg`);
                });
              }),
            [
              {
                ...t,
                easing: "quadOut",
                keyframes: [
                  { opacity: 0 },
                  { opacity: "var(--comp-opacity, 1)" },
                ],
              },
              {
                ...t,
                easing: o,
                keyframes: [
                  {
                    transform: `rotate(var(--comp-rotate-z, 0deg)) translate(var(--motion-origin-x ,${i}%), var(--motion-origin-y, ${c}%)) perspective(800px) rotateX(var(--motion-rotate-x, ${l.x}deg)) rotateY(var(--motion-rotate-y, ${l.y}deg)) translate(calc(-1 * var(--motion-origin-x ,${i}%)), calc(-1 * var(--motion-origin-y, ${c}%)))`,
                  },
                  {
                    transform: `rotate(var(--comp-rotate-z, 0deg)) translate(var(--motion-origin-x ,${i}%), var(--motion-origin-y, ${c}%)) perspective(800px) rotateX(0deg) rotateY(0deg) translate(calc(-1 * var(--motion-origin-x ,${i}%)), calc(-1 * var(--motion-origin-y, ${c}%)))`,
                  },
                ],
              },
            ]
          );
        },
        GlideIn: function (t, e) {
          const {
              direction: a = 0,
              distance: r = { value: 100, type: "percentage" },
              power: n,
              startFromOffScreen: o = !1,
            } = t.namedEffect,
            s = (a * Math.PI) / 180,
            i = _(r.type);
          let c = 0,
            l = 0;
          e &&
            o &&
            (e.measure((t) => {
              if (!t) return;
              const { left: e, top: a } = t.getBoundingClientRect();
              (c = e), (l = a);
            }),
            e.mutate((t) => {
              null == t || t.style.setProperty("--motion-left", `${c}px`),
                null == t || t.style.setProperty("--motion-top", `${l}px`);
            }));
          const f = (n && le[n]) || t.easing || "quintInOut",
            { x: m, y: p } = B(a),
            u = o ? m : `${Math.sin(s) * r.value}${i}`,
            d = o ? p : `${Math.cos(s) * r.value * -1}${i}`;
          return [
            {
              ...t,
              easing: f,
              keyframes: [
                { opacity: "var(--comp-opacity, 1)", translate: `${u} ${d}` },
                { opacity: "var(--comp-opacity, 1)", translate: "0 0" },
              ],
            },
          ];
        },
        GlitchIn: function (t, e) {
          const {
              direction: a = 270,
              distance: r = { value: 100, type: "percentage" },
              power: n,
              startFromOffScreen: o = !1,
            } = t.namedEffect,
            s = (a * Math.PI) / 180,
            i = _(r.type);
          let c = 0,
            l = 0;
          e &&
            o &&
            (e.measure((t) => {
              if (!t) return;
              const { left: e, top: a } = t.getBoundingClientRect();
              (c = e), (l = a);
            }),
            e.mutate((t) => {
              null == t || t.style.setProperty("--motion-left", `${c}px`),
                null == t || t.style.setProperty("--motion-top", `${l}px`);
            }));
          const f = (n && fe[n]) || t.easing || "quintInOut",
            { x: m, y: p } = B(a - 90),
            u = o ? m : `${Math.sin(s) * r.value}${i}`,
            d = o ? p : `${Math.cos(s) * r.value * -1}${i}`;
          return [
            {
              ...t,
              easing: f,
              keyframes: [
                { opacity: "var(--comp-opacity, 1)", translate: `${u} ${d}` },
                { opacity: "var(--comp-opacity, 1)", translate: "0 0" },
              ],
            },
          ];
        },
        GrowIn: function (t) {
          const {
              power: e,
              initialScale: a = 0,
              distance: r = { value: 120, type: "percentage" },
              direction: n = 0,
            } = t.namedEffect,
            o = t.easing || "cubicInOut",
            s = void 0 !== e ? me[e] : a,
            i = (n * Math.PI) / 180,
            c = _(r.type),
            l = `${Math.sin(i) * r.value}${c}`,
            f = `${Math.cos(i) * r.value * -1}${c}`;
          return [
            {
              ...t,
              easing: o,
              duration: t.duration * s,
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
            {
              ...t,
              easing: o,
              keyframes: [
                { scale: `${s}`, translate: `${l} ${f}` },
                { scale: "1", translate: "0px 0px" },
              ],
            },
          ];
        },
        PunchIn: function (t, e) {
          const { direction: a = "top-right", power: r = "medium" } =
              t.namedEffect,
            { in: n, out: o } = T(ue[r]),
            s = pe[a],
            i = `calc(var(--motion-width, 100%) * 1.1 / 2 * ${s.x})`,
            c = `calc(var(--motion-height, 100%) * 1.1 / 2 * ${s.y})`,
            l = [
              { offset: 30, scale: 0.3, factor: 1, ease: "linear" },
              { offset: 45, scale: 1.4, factor: -0.4, ease: o },
              { offset: 62.65, scale: 0.8, factor: 0.2, ease: n },
              { offset: 77.27, scale: 1.1, factor: -0.1, ease: o },
              { offset: 86.23, scale: 0.94, factor: 0.06, ease: n },
              { offset: 91.73, scale: 1.03, factor: -0.03, ease: o },
              { offset: 95.11, scale: 0.98, factor: 0.02, ease: n },
              { offset: 97.18, scale: 1.01, factor: -0.01, ease: o },
              { offset: 98.45, scale: 0.99, factor: 0.01, ease: n },
              { offset: 100, scale: 1, factor: 0, ease: o },
            ].map((t) => {
              let { offset: e, scale: a, ease: r, factor: n } = t;
              const { x: o, y: i } = (function (t, e, a) {
                return {
                  x: `calc(var(--motion-width, 100%) * 1.1 / 3 * ${t} * ${a})`,
                  y: `calc(var(--motion-height, 100%) * 1.1 / 3 * ${e} * ${a})`,
                };
              })(s.x, s.y, n);
              return {
                offset: e / 100,
                easing: S(r),
                scale: `${a}`,
                translate: `${o} ${i}`,
              };
            });
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const { width: a, height: r } = t.getBoundingClientRect();
                e.mutate(() => {
                  t.style.setProperty("--motion-width", `${a}px`),
                    t.style.setProperty("--motion-height", `${r}px`);
                });
              }),
            [
              {
                ...t,
                easing: "cubicIn",
                duration: 0.3 * t.duration,
                keyframes: [
                  { opacity: 0 },
                  { opacity: "var(--comp-opacity, 1)" },
                ],
              },
              {
                ...t,
                easing: "linear",
                keyframes: [
                  { translate: `${i} ${c}`, scale: "0", easing: O.expoIn },
                  ...l,
                ],
              },
            ]
          );
        },
        ShapeIn: function (t) {
          const { shape: e = "rectangle" } = t.namedEffect,
            a = t.easing || "cubicInOut",
            { start: r, end: n } = de[e];
          return [
            {
              ...t,
              easing: "quadOut",
              duration: 0.8 * t.duration,
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
            { ...t, easing: a, keyframes: [{ clipPath: r }, { clipPath: n }] },
          ];
        },
        RevealIn: function (t, e) {
          const { direction: a = "left" } = t.namedEffect,
            r = t.easing || "cubicInOut",
            n = ye(0, a);
          e &&
            e.measure((t) => {
              if (!t) return;
              const r =
                getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                "0deg";
              e.mutate((t) => {
                null == t ||
                  t.style.setProperty(
                    "--motion-clip-path",
                    ye(parseInt(r, 10), a)
                  );
              });
            });
          const o = P({ direction: "initial" });
          return [
            {
              ...t,
              easing: r,
              keyframes: [
                { clipPath: `var(--motion-clip-path, ${n})` },
                { clipPath: o },
              ],
            },
          ];
        },
        SlideIn: function (t, e) {
          const {
              direction: a = "left",
              power: r,
              initialTranslate: n = 1,
            } = t.namedEffect,
            o = t.easing || "cubicInOut",
            s = 100 - 100 * ((r && $e[r]) || n),
            i = P({ direction: a, minimum: s });
          e &&
            e.measure((t) => {
              if (!t) return;
              const r = parseInt(
                getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                  "0deg",
                10
              );
              e.mutate((t) => {
                const e = z(ve, a, r);
                null == t ||
                  t.style.setProperty(
                    "--motion-clip-path",
                    P({ direction: he[e].clip, minimum: s })
                  ),
                  null == t ||
                    t.style.setProperty(
                      "--motion-translate-x",
                      100 * he[e].dx + "%"
                    ),
                  null == t ||
                    t.style.setProperty(
                      "--motion-translate-y",
                      100 * he[e].dy + "%"
                    );
              });
            });
          const c = P({ direction: "initial" }),
            l = {
              ...t,
              easing: "cubicInOut",
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            };
          return [
            {
              ...t,
              easing: o,
              keyframes: [
                {
                  transform:
                    "rotate(var(--comp-rotate-z, 0deg)) translate(var(--motion-translate-x, -100%), var(--motion-translate-y, 0%))",
                  clipPath: `var(--motion-clip-path, ${i})`,
                },
                {
                  transform:
                    "rotate(var(--comp-rotate-z, 0deg)) translate(0px, 0px)",
                  clipPath: c,
                },
              ],
            },
            ...("hard" !== r ? [l] : []),
          ];
        },
        SpinIn: function (t) {
          const {
              direction: e = "clockwise",
              spins: a = 0.5,
              initialScale: r = 0,
              power: n,
            } = t.namedEffect,
            o = t.easing || "cubicInOut",
            s = void 0 !== n ? xe[n] : r,
            i = 360 * (be[e] > 0 ? 1 : -1) * a;
          return [
            {
              ...t,
              easing: "cubicIn",
              duration: t.duration * s,
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
            {
              ...t,
              easing: o,
              keyframes: [
                { scale: `${s}`, rotate: `${i}deg` },
                { scale: "1", rotate: "0deg" },
              ],
            },
          ];
        },
        TiltIn: function (t, e) {
          const { direction: a = "left" } = t.namedEffect,
            r = t.easing || "cubicOut",
            n = Ee(0),
            o = ke[a],
            s = P({ direction: "initial" }),
            i = "calc(var(--motion-height, 200px) / 2)";
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const a = t.getBoundingClientRect().height,
                  r =
                    getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                    "0deg";
                e.mutate((t) => {
                  null == t || t.style.setProperty("--motion-height", `${a}px`),
                    null == t ||
                      t.style.setProperty(
                        "--motion-clip-path",
                        Ee(parseInt(r, 10))
                      );
                });
              }),
            [
              {
                ...t,
                duration: 0.2 * t.duration,
                easing: "cubicOut",
                keyframes: [
                  { opacity: 0 },
                  { opacity: "var(--comp-opacity, 1)" },
                ],
              },
              {
                ...t,
                easing: r,
                keyframes: [
                  {
                    transform: ` perspective(800px) translateZ(calc(${i} * -1)) rotateX(-90deg) translateZ(${i}) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                  {
                    transform: ` perspective(800px) translateZ(calc(${i} * -1)) rotateX(0deg) translateZ(${i}) rotate(var(--comp-rotate-z, 0deg))`,
                  },
                ],
              },
              {
                ...t,
                easing: r,
                composite: "add",
                duration: 0.8 * t.duration,
                keyframes: [
                  {
                    clipPath: `var(--motion-clip-path, ${n})`,
                    transform: `rotateZ(${o}deg)`,
                  },
                  { clipPath: s, transform: "rotateZ(0deg)" },
                ],
              },
            ]
          );
        },
        TurnIn: function (t) {
          const { direction: e = "top-left", power: a } = t.namedEffect,
            r = a && Ye[a] ? Ye[a] : t.easing || "backOut",
            { x: n, y: o } = Oe[e],
            s = Oe[e].angle;
          return [
            {
              ...t,
              duration: 0.6 * t.duration,
              easing: "sineIn",
              keyframes: [
                { opacity: 0 },
                { opacity: "var(--comp-opacity, 1)" },
              ],
            },
            {
              ...t,
              easing: r,
              keyframes: [
                {
                  transform: `translate(${n}%, ${o}%) rotate(${s}deg) translate(${-n}%, ${-o}%) rotate(var(--comp-rotate-z, 0deg))`,
                },
                {
                  transform: `translate(${n}%, ${o}%) rotate(0deg) translate(${-n}%, ${-o}%) rotate(var(--comp-rotate-z, 0deg))`,
                },
              ],
            },
          ];
        },
        WinkIn: function (t, e) {
          const { direction: a = "horizontal" } = t.namedEffect,
            r = z(Pe, a, 0),
            { scaleX: n, scaleY: o } = Ie[r],
            s = t.easing || "quintInOut",
            i = P({ direction: a, minimum: 100 }),
            c = P({ direction: "initial" });
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const r =
                    getComputedStyle(t).getPropertyValue("--comp-rotate-z") ||
                    "0",
                  n = z(Pe, a, parseInt(r, 10)),
                  o = Ie[n],
                  s = P({ direction: n, minimum: 100 });
                e.mutate(() => {
                  t.style.setProperty("--motion-clip-path", s),
                    t.style.setProperty("--motion-scale-x", `${o.scaleX}`),
                    t.style.setProperty("--motion-scale-y", `${o.scaleY}`);
                });
              }),
            [
              {
                ...t,
                easing: "quadOut",
                keyframes: [
                  { opacity: 0 },
                  { opacity: "var(--comp-opacity, 1)" },
                ],
              },
              {
                ...t,
                easing: s,
                keyframes: [
                  {
                    offset: 0,
                    clipPath: `var(--motion-clip-path, ${i})`,
                    transform: `rotate(var(--comp-rotate-z, 0deg)) scale(var(--motion-scale-x, ${n}), var(--motion-scale-y, ${o}))`,
                  },
                  {
                    offset: 0.85,
                    transform: "rotate(var(--comp-rotate-z, 0deg)) scale(1, 1)",
                  },
                  {
                    offset: 1,
                    transform: "rotate(var(--comp-rotate-z, 0deg)) scale(1, 1)",
                    clipPath: c,
                  },
                ],
              },
            ]
          );
        },
      };
      var Xe = a(41217);
      const _e = { soft: 1, medium: 2, hard: 3 },
        Se = [
          { keyframe: 0, translateY: 0 },
          { keyframe: 8.8, translateY: -55 },
          { keyframe: 17.6, translateY: -87 },
          { keyframe: 26.5, translateY: -98 },
          { keyframe: 35.3, translateY: -87 },
          { keyframe: 44.1, translateY: -55 },
          { keyframe: 53.1, translateY: 0 },
          { keyframe: 66.2, translateY: -23 },
          { keyframe: 81, translateY: 0 },
          { keyframe: 86.8, translateY: -5 },
          { keyframe: 94.1, translateY: 0 },
          { keyframe: 97.1, translateY: -2 },
          { keyframe: 100, translateY: 0 },
        ];
      const Te = {
        vertical: "translateY",
        horizontal: "translateX",
        center: "translateZ",
      };
      function Me(t, e) {
        let { value: a, type: r = "px" } = t;
        void 0 === e && (e = 1);
        return `${a * e}${_(r)}`;
      }
      const Ae = {
          soft: { maxScaleBy: 0, maxTranslateBy: 50 },
          medium: { maxScaleBy: 0.5, maxTranslateBy: 100 },
          hard: { maxScaleBy: 0.7, maxTranslateBy: 200 },
        },
        Be = { translate: "0 0", scale: 1 },
        Ve = 500,
        Ze = 0,
        Re = 0.7,
        Ce = (t) => [0.3, 0.45, 0.7].map((e) => (t * e) % 1);
      const {
          RIGHT: Fe,
          LEFT: De,
          TOP: Ge,
          BOTTOM: qe,
        } = {
          RIGHT:
            "calc(var(--motion-parent-width, 100vw) - var(--motion-left, 0px))",
          LEFT: "calc(var(--motion-left, calc(var(--motion-parent-width, 100vw) - var(--motion-width, 100%))) * -1 - var(--motion-width, 100%))",
          TOP: "calc(var(--motion-top, calc(var(--motion-parent-height, 100vh) - var(--motion-height, 100%))) * -1 - var(--motion-height, 100%))",
          BOTTOM:
            "calc(var(--motion-parent-height, 100vh) - var(--motion-top, 0px))",
        },
        He = {
          "top-left": {
            from: `min(${Fe}, ${qe})`,
            to: `min(calc(${De} * -1), calc(${Ge} * -1))`,
          },
          "top-right": {
            from: `min(calc(${De} * -1), ${qe})`,
            to: `min(${Fe}, calc(${Ge} * -1))`,
          },
          "bottom-left": {
            from: `min(${Fe}, calc(${Ge} * -1))`,
            to: `min(calc(${De} * -1), ${qe})`,
          },
          "bottom-right": {
            from: `min(calc(${De} * -1), calc(${Ge} * -1))`,
            to: `min(${Fe}, ${qe})`,
          },
        },
        We = {
          left: { from: `${Fe} 0`, to: `${De} 0` },
          right: { from: `${De} 0`, to: `${Fe} 0` },
          top: { from: `0 ${qe}`, to: `0 ${Ge}` },
          bottom: { from: `0 ${Ge}`, to: `0 ${qe}` },
        },
        Le = {
          left: (t) => {
            let { left: e, width: a, parentWidth: r } = t;
            return (a + e) / (r + a || 1);
          },
          right: (t) => {
            let { left: e, width: a, parentWidth: r } = t;
            return (r - e) / (r + a || 1);
          },
          bottom: (t) => {
            let { top: e, height: a, parentHeight: r } = t;
            return (r - e) / (r + a || 1);
          },
          top: (t) => {
            let { top: e, height: a, parentHeight: r } = t;
            return (a + e) / (r + a || 1);
          },
          "bottom-right": (t) => {
            let {
              left: e,
              top: a,
              width: r,
              height: n,
              parentWidth: o,
              parentHeight: s,
            } = t;
            const i = r + e,
              c = s - a;
            return i < c ? i / (o + r || 1) : c / (s + n || 1);
          },
          "bottom-left": (t) => {
            let {
              left: e,
              top: a,
              width: r,
              height: n,
              parentWidth: o,
              parentHeight: s,
            } = t;
            const i = o - e,
              c = s - a;
            return i < c ? i / (o + r || 1) : c / (s + n || 1);
          },
          "top-right": (t) => {
            let {
              left: e,
              top: a,
              width: r,
              height: n,
              parentWidth: o,
              parentHeight: s,
            } = t;
            const i = o - e,
              c = n + a;
            return i < c ? i / (o + r || 1) : c / (s + n || 1);
          },
          "top-left": (t) => {
            let {
              left: e,
              top: a,
              width: r,
              height: n,
              parentWidth: o,
              parentHeight: s,
            } = t;
            const i = o - e,
              c = n + a;
            return i < c ? i / (o + r || 1) : c / (s + n || 1);
          },
        };
      const Ue = { soft: "linear", medium: "quintInOut", hard: "backOut" },
        je = { vertical: "rotateX", horizontal: "rotateY" };
      const Je = { soft: 1, medium: 2, hard: 3 },
        Ke = {
          top: { rotationAxis: "rotateX", origin: { x: 0, y: -50 } },
          right: { rotationAxis: "rotateY", origin: { x: 50, y: 0 } },
          bottom: { rotationAxis: "rotateX", origin: { x: 0, y: 50 } },
          left: { rotationAxis: "rotateY", origin: { x: -50, y: 0 } },
        },
        Ne = 15;
      const Qe = { soft: 1, medium: 2, hard: 4 },
        ta = [
          { keyframe: 24, skewY: 7 },
          { keyframe: 38, skewY: -2 },
          { keyframe: 58, skewY: 4 },
          { keyframe: 80, skewY: -2 },
          { keyframe: 100, skewY: 0 },
        ];
      const ea = [
          { keyframe: 17, translate: 7 },
          { keyframe: 32, translate: 25 },
          { keyframe: 48, translate: 8 },
          { keyframe: 56, translate: 11 },
          { keyframe: 66, translate: 25 },
          { keyframe: 83, translate: 4 },
          { keyframe: 100, translate: 0 },
        ],
        aa = { soft: 1, medium: 2, hard: 4 },
        ra = {
          top: { axis: "y", transformDirection: -1 },
          bottom: { axis: "y", transformDirection: 1 },
          right: { axis: "x", transformDirection: 1 },
          left: { axis: "x", transformDirection: -1 },
        };
      const na = { soft: 0, medium: 0.05, hard: 0.1 },
        oa = [
          { keyframe: 45, scaleX: 1.03, scaleY: 0.93 },
          { keyframe: 56, scaleX: 0.9, scaleY: 1.03 },
          { keyframe: 66, scaleX: 1.02, scaleY: 0.96 },
          { keyframe: 78, scaleX: 0.98, scaleY: 1.02 },
          { keyframe: 89, scaleX: 1.005, scaleY: 0.9995 },
          { keyframe: 100, scaleX: 1, scaleY: 1 },
        ];
      const sa = { soft: 0, medium: 0.06, hard: 0.12 },
        ia = [
          { keyframe: 27, scale: 0.96 },
          { keyframe: 45, scale: 1 },
          { keyframe: 72, scale: 0.93 },
          { keyframe: 100, scale: 1 },
        ];
      const ca = { soft: "linear", medium: "quintInOut", hard: "backOut" },
        la = { clockwise: -1, "counter-clockwise": 1 };
      const fa = { soft: 1, medium: 2, hard: 3 },
        ma = {
          top: { transAxis: "translateY", transValue: -50 },
          right: { transAxis: "translateX", transValue: 50 },
          bottom: { transAxis: "translateY", transValue: 50 },
          left: { transAxis: "translateX", transValue: -50 },
        };
      const pa = { soft: 1, medium: 2, hard: 4 },
        ua = [
          { keyframe: 18, transY: -10, accRotate: 10 },
          { keyframe: 35, transY: 0, accRotate: -18 },
          { keyframe: 53, transY: 0, accRotate: 14 },
          { keyframe: 73, transY: 0, accRotate: -10 },
          { keyframe: 100, transY: 0, accRotate: 4 },
        ];
      const da = {
        Bounce: function (t) {
          const { power: e = "soft", intensity: a = 0.3 } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = (0, Xe._b)(0, 1, _e.soft, _e.hard, a),
            s = _e[e] || o,
            i = S("sineOut"),
            c = Se.map((t) => {
              let { keyframe: e, translateY: a } = t;
              return {
                offset: (e / 100) * (r / (r + n)),
                translate: `0px ${(a * s) / 2}px`,
                easing: i,
              };
            });
          return [
            { ...t, delay: 0, easing: "linear", duration: r + n, keyframes: c },
          ];
        },
        Breathe: function (t) {
          const {
              direction: e = "vertical",
              distance: a = { value: 25, type: "px" },
            } = t.namedEffect,
            r = t.easing || "sineInOut",
            n = t.duration || 0,
            o = t.delay || 0,
            s = Te[e],
            i = Me(a),
            c = T(r),
            l = 3.2 * n + o,
            f = (function (t, e) {
              return [
                { frameTravel: Me(t), frameTime: e / 4 },
                { frameTravel: Me(t, -1), frameTime: e / 2 },
                { frameTravel: Me(t), frameTime: e / 2 },
                { frameTravel: Me(t, -0.7), frameTime: e / 2 },
                { frameTravel: Me(t, 0.6), frameTime: e / 3 },
              ];
            })(a, n),
            m = "center" === e ? "perspective(800px) " : "";
          let p = 0;
          const u = o
            ? f.map((t) => {
                let { frameTravel: e, frameTime: a } = t;
                const r = p + a / l;
                return (
                  (p = r),
                  {
                    offset: r,
                    easing: S(c.inOut),
                    transform: `${m}${[
                      s,
                    ]}(${e}) rotateZ(var(--comp-rotate-z, 0deg))`,
                  }
                );
              })
            : [
                {
                  offset: 0.25,
                  easing: S(c.inOut),
                  transform: `${m} ${[
                    s,
                  ]}(${i}) rotateZ(var(--comp-rotate-z, 0deg))`,
                },
                {
                  offset: 0.75,
                  easing: S(c.in),
                  transform: `${m}${[
                    s,
                  ]}(-${i}) rotateZ(var(--comp-rotate-z, 0deg))`,
                },
              ];
          return [
            {
              ...t,
              easing: "linear",
              delay: 0,
              duration: o ? l : n,
              keyframes: [
                {
                  offset: 0,
                  easing: S(c.out),
                  transform: `${m} ${[
                    s,
                  ]}(0) rotateZ(var(--comp-rotate-z, 0deg))`,
                },
                ...u,
                {
                  offset: 1,
                  transform: `${m} ${[
                    s,
                  ]}(0) rotateZ(var(--comp-rotate-z, 0deg))`,
                },
              ],
            },
          ];
        },
        Blink: function (t) {
          const {
              power: e,
              scale: a = 0,
              distance: r = { value: 50, type: "percentage" },
            } = t.namedEffect,
            n = void 0 === e,
            o = t.duration ?? 0,
            s = t.delay ?? 0,
            i = 9 * (o + s + 1e3),
            c = S((n && t.easing) || "backInOut"),
            l = _(r.type),
            f = [],
            m = (0, Xe._b)(0, 1, Ze, Re, a),
            { maxScaleBy: p, maxTranslateBy: u } = n
              ? { maxScaleBy: m, maxTranslateBy: r.value }
              : Ae[e];
          for (let t = 0; t < 10; t++) {
            const e = Ce(t + 1),
              a = Math.round(2 * e[0] * u) - u,
              r = {
                translate: `${Math.round(2 * e[1] * u) - u}${l} ${a}${l}`,
                scale: 1 + e[2] * p * (t % 2 == 0 ? 1 : -1),
                easing: c,
                ...(0 === t || 9 === t ? Be : {}),
              },
              n = {
                hiddenEnd: (Ve * (2 * t - 1) + o * (t - 1) + s * t) / i,
                visibleStart: (Ve * (2 * t) + o * (t - 1) + s * t) / i,
                visibleEnd: (Ve * (2 * t) + o * t + s * t) / i,
                hiddenStart: (Ve * (2 * t + 1) + o * t + s * t) / i,
              };
            t > 0 &&
              f.push(
                {
                  ...r,
                  opacity: 0,
                  scale: r.scale - 0.02,
                  offset: n.hiddenEnd,
                },
                { ...r, opacity: 1, offset: n.visibleStart }
              ),
              f.push({ ...r, opacity: 1, offset: n.visibleEnd }),
              t < 9 &&
                f.push({
                  ...r,
                  opacity: 0,
                  scale: r.scale - 0.02,
                  offset: n.hiddenStart,
                });
          }
          return [
            { ...t, easing: "linear", delay: 0, duration: i, keyframes: f },
          ];
        },
        Cross: function (t, e) {
          const { direction: a = "right" } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = r / (r + n || 1);
          let s = 0,
            i = 0,
            c = 0,
            l = 0,
            f = 0,
            m = 0;
          return (
            e &&
              (e.measure((t) => {
                if (!t) return;
                const { width: e, height: a } = t.getBoundingClientRect(),
                  r = t.offsetParent,
                  n = (null == r ? void 0 : r.getBoundingClientRect()) || {},
                  o = Z(t, r);
                (s = o.left),
                  (i = o.top),
                  (c = e),
                  (l = a),
                  (f = n.width),
                  (m = n.height);
              }),
              e.mutate((t) => {
                null == t || t.style.setProperty("--motion-left", `${s}px`),
                  null == t || t.style.setProperty("--motion-top", `${i}px`),
                  null == t || t.style.setProperty("--motion-width", `${c}px`),
                  null == t || t.style.setProperty("--motion-height", `${l}px`),
                  null == t ||
                    t.style.setProperty("--motion-parent-width", `${f}px`),
                  null == t ||
                    t.style.setProperty("--motion-parent-height", `${m}px`);
              })),
            [
              {
                ...t,
                delay: 0,
                easing: "linear",
                duration: r + n,
                get keyframes() {
                  const t =
                    Le[a]({
                      left: s,
                      top: i,
                      width: c,
                      height: l,
                      parentWidth: f,
                      parentHeight: m,
                    }) * o;
                  let e, p;
                  if (a in We) (e = We[a].from), (p = We[a].to);
                  else {
                    const t = (function (t) {
                      const e = He[t].from,
                        a = He[t].to,
                        r = t.startsWith("top") ? 1 : -1,
                        n = -r,
                        o = t.endsWith("left") ? 1 : -1;
                      return {
                        from: `calc(${e} * ${o}) calc(${e} * ${r})`,
                        to: `calc(${a} * ${-o}) calc(${a} * ${n})`,
                      };
                    })(a);
                    (e = t.from), (p = t.to);
                  }
                  return [
                    { offset: 0, translate: "0 0" },
                    { offset: t, translate: p, easing: "step-start" },
                    { offset: t + 1e-4, translate: e },
                    { offset: r / (r + n || 1), translate: "0 0" },
                    { offset: 1, translate: "0 0" },
                  ];
                },
              },
            ]
          );
        },
        DVD: function (t, e) {
          const a = t.duration || 0,
            r = t.delay || 0;
          let n = 0,
            o = 0,
            s = 0,
            i = 0,
            c = (16 / 9) * 0.5;
          return (
            e &&
              e.measure((t) => {
                if (!t) return;
                const a = t.getBoundingClientRect(),
                  { width: r, height: l } = a,
                  f =
                    t.closest("[data-block-level-container]") || t.offsetParent,
                  m = Z(t, f);
                (n = m.left),
                  (o = m.top),
                  (s = (null == f ? void 0 : f.offsetWidth) || 0),
                  (i = (null == f ? void 0 : f.offsetHeight) || 0),
                  (c = (s / i) * 0.5),
                  e.mutate(() => {
                    t.style.setProperty("--motion-left", `${n}px`),
                      t.style.setProperty("--motion-top", `${o}px`),
                      t.style.setProperty("--motion-width", `${r}px`),
                      t.style.setProperty("--motion-height", `${l}px`),
                      t.style.setProperty("--motion-parent-width", `${s}px`),
                      t.style.setProperty("--motion-parent-height", `${i}px`);
                  });
              }),
            [
              {
                ...t,
                easing: "linear",
                delay: r,
                duration: a / c,
                alternate: !0,
                keyframes: [
                  { translate: "calc(-1 * var(--motion-left, 0px))" },
                  {
                    translate:
                      "calc(var(--motion-parent-width, 100vw) - var(--motion-left, 0px) - var(--motion-width, 100%))",
                  },
                ],
                get timing() {
                  return { iterationStart: n && s ? n / s : 0 };
                },
              },
              {
                ...t,
                easing: "linear",
                delay: r,
                duration: a * c,
                alternate: !0,
                composite: "add",
                keyframes: [
                  { translate: "0 calc(-1 * var(--motion-top, 0px))" },
                  {
                    translate:
                      "0 calc(var(--motion-parent-height, 100vh) - var(--motion-top, 0px) - var(--motion-height, 100%))",
                  },
                ],
                get timing() {
                  return { iterationStart: o && i ? o / i : 0 };
                },
              },
            ]
          );
        },
        Flash: function (t) {
          const e = t.duration || 0,
            a = t.delay || 0,
            r = S(t.easing || "cubicInOut");
          return [
            {
              ...t,
              easing: "linear",
              delay: 0,
              duration: e + a,
              keyframes: [
                { offset: 0, opacity: 1, easing: r },
                { offset: (e / (e + a || 1)) * 0.5, opacity: 0, easing: r },
                { offset: e / (e + a || 1), opacity: 1 },
                { offset: 1, opacity: 1 },
              ],
            },
          ];
        },
        Flip: function (t) {
          const { direction: e = "horizontal", power: a } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = je[e],
            s = (a && Ue[a]) || t.easing || "linear";
          return [
            {
              ...t,
              delay: 0,
              easing: "linear",
              duration: r + n,
              keyframes: [
                {
                  offset: 0,
                  transform: `perspective(800px) rotateZ(var(--comp-rotate-z, 0deg)) ${o}(0deg)`,
                  easing: S(s),
                },
                {
                  offset: r / (r + n),
                  transform: `perspective(800px) rotateZ(var(--comp-rotate-z, 0deg)) ${o}(360deg)`,
                },
                {
                  offset: 1,
                  transform: `perspective(800px) rotateZ(var(--comp-rotate-z, 0deg)) ${o}(360deg)`,
                },
              ],
            },
          ];
        },
        Fold: function (t) {
          const {
              direction: e = "top",
              power: a,
              angle: r = Ne,
            } = t.namedEffect,
            n = t.easing || "cubicInOut",
            o = t.duration || 0,
            s = +(t.delay || 0),
            i = void 0 === a,
            { rotationAxis: c, origin: l } = Ke[e],
            { x: f, y: m } = l,
            p = T(i ? n : "cubicInOut"),
            u = i ? r : Ne * Je[a],
            d = 3.2 * o + s;
          let g = 0;
          const y = `rotateZ(var(--comp-rotate-z, 0deg)) translateX(${f}%) translateY(${m}%) perspective(800px)`,
            h = `translateX(${-f}%) translateY(${-m}%)`,
            v = (t) => `${y} ${[c]}(${t}deg) ${h}`,
            $ = s
              ? (function (t, e) {
                  return [
                    { fold: t, frameTime: e / 4 },
                    { fold: -0.7 * t, frameTime: e / 2 },
                    { fold: 0.6 * t, frameTime: e / 2 },
                    { fold: -0.3 * t, frameTime: 0.45 * e },
                    { fold: 0.2 * t, frameTime: 0.4 * e },
                    { fold: -0.05 * t, frameTime: e / 2 },
                    { fold: 0, frameTime: 0.35 * e },
                  ];
                })(u, o).map((t) => {
                  let { fold: e, frameTime: a } = t;
                  const r = g + a / d;
                  return (
                    (g = r),
                    { offset: r, easing: S("sineInOut"), transform: v(e) }
                  );
                })
              : [
                  { offset: 0.25, easing: S(p.inOut), transform: v(u) },
                  { offset: 0.75, easing: S(p.in), transform: v(-u) },
                ],
            x = v(0);
          return [
            {
              ...t,
              easing: "linear",
              delay: 0,
              duration: s ? d : o,
              keyframes: [
                { offset: 0, easing: S(p.out), transform: x },
                ...$,
                { offset: 1, transform: x },
              ],
            },
          ];
        },
        Jello: function (t) {
          const { power: e, intensity: a = 0.25 } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = (0, Xe._b)(0, 1, Qe.soft, Qe.hard, a),
            s = (e && Qe[e]) || o,
            i = ta.map((t) => {
              let { keyframe: e, skewY: a } = t;
              return {
                offset: (e / 100) * (r / (r + n)),
                transform: `rotateZ(var(--comp-rotate-z, 0deg)) skewY(${
                  a * s
                }deg)`,
              };
            });
          return [
            { ...t, delay: 0, easing: "linear", duration: r + n, keyframes: i },
          ];
        },
        Poke: function (t) {
          const {
              power: e,
              intensity: a = 0.5,
              direction: r = "right",
            } = t.namedEffect,
            n = t.duration || 0,
            o = +(t.delay || 0),
            { axis: s, transformDirection: i } = ra[r],
            c = (0, Xe._b)(0, 1, aa.soft, aa.hard, a),
            l = e ? aa[e] : c,
            f = ea.map((t) => {
              let { keyframe: e, translate: a } = t;
              const r = a * l * i;
              return {
                offset: (e / 100) * (n / (n + o)),
                translate: "x" === s ? `${r}px` : `0px ${r}px`,
              };
            });
          return [{ ...t, delay: 0, duration: n + o, keyframes: f }];
        },
        Rubber: function (t) {
          const { power: e, intensity: a = 0.5 } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = (0, Xe._b)(0, 1, na.soft, na.hard, a),
            s = void 0 !== e ? na[e] : o,
            i = oa.map((t, e) => {
              let { keyframe: a, scaleX: o, scaleY: i } = t;
              const c = e === oa.length - 1,
                l = s * (c ? 0 : e % 2 == 0 ? 1 : -0.5);
              return {
                offset: (a / 100) * (r / (r + n)),
                transform: `rotateZ(var(--comp-rotate-z, 0deg)) scale(${
                  o + l
                }, ${i - l})`,
              };
            });
          return [{ ...t, delay: 0, duration: r + n, keyframes: i }];
        },
        Pulse: function (t) {
          const { power: e, intensity: a = 0 } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = (0, Xe._b)(0, 1, sa.soft, sa.hard, a),
            s = void 0 !== e ? sa[e] : o,
            i = ia.map((t) => {
              let { keyframe: e, scale: a } = t;
              return {
                offset: (e / 100) * (r / (r + n)),
                scale: "" + (a - (a < 1 ? s : 0)),
              };
            });
          return [
            {
              ...t,
              delay: 0,
              duration: r + n,
              keyframes: [...i, { offset: 1, scale: 1 }],
            },
          ];
        },
        Spin: function (t) {
          const { power: e, direction: a = "clockwise" } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = (e && ca[e]) || t.easing || "linear",
            s = 360 * (la[a] > 0 ? 1 : -1);
          return [
            {
              ...t,
              easing: o,
              delay: 0,
              duration: r + n,
              keyframes: [
                {
                  offset: 0,
                  rotate: `calc(var(--comp-rotate-z, 0deg) + ${s}deg)`,
                },
                { offset: r / (r + n), rotate: "var(--comp-rotate-z, 0deg)" },
              ],
            },
          ];
        },
        Swing: function (t) {
          const {
              power: e,
              swing: a = 20,
              direction: r = "top",
            } = t.namedEffect,
            n = t.duration || 0,
            o = t.delay || 0,
            s = t.easing || "sineInOut",
            i =
              "linear" === s
                ? { in: "linear", inOut: "linear", out: "linear" }
                : T(s),
            c = void 0 !== e ? 20 * fa[e] : a,
            { transAxis: l, transValue: f } = ma[r],
            m = 3.55 * n + o,
            p = (function (t, e) {
              return [
                { angle: t, frameTime: e / 4 },
                { angle: -t, frameTime: e / 2 },
                { angle: 0.6 * t, frameTime: e / 2 },
                { angle: -0.3 * t, frameTime: e / 2 },
                { angle: 0.2 * t, frameTime: e / 2 },
                { angle: -0.05 * t, frameTime: e / 2 },
                { angle: 0, frameTime: 0.4 * e },
              ];
            })(c, n);
          let u = 0;
          const d = o
            ? p.map((t) => {
                let { angle: e, frameTime: a } = t;
                const r = u + a / m;
                return (
                  (u = r),
                  {
                    offset: r,
                    easing: S(i.inOut),
                    transform: `rotate(var(--comp-rotate-z, 0deg)) ${l}(${f}%) rotate(${e}deg) ${l}(${
                      -1 * f
                    }%)`,
                  }
                );
              })
            : [
                {
                  offset: 0.25,
                  easing: S(i.inOut),
                  transform: `rotate(var(--comp-rotate-z, 0deg)) ${l}(${f}%) rotate(${+c}deg) ${l}(${
                    -1 * f
                  }%)`,
                },
                {
                  offset: 0.75,
                  easing: S(i.in),
                  transform: `rotate(var(--comp-rotate-z, 0deg)) ${l}(${f}%) rotate(${-c}deg) ${l}(${
                    -1 * f
                  }%)`,
                },
              ];
          return [
            {
              ...t,
              easing: "linear",
              delay: 0,
              duration: o ? m : n,
              keyframes: [
                {
                  offset: 0,
                  easing: S(i.out),
                  transform: `rotateZ(var(--comp-rotate-z, 0deg)) ${l}(${f}%) rotate(0deg) ${l}(${
                    -1 * f
                  }%)`,
                },
                ...d,
                {
                  offset: 1,
                  transform: `rotateZ(var(--comp-rotate-z, 0deg)) ${l}(${f}%) rotate(0deg) ${l}(${
                    -1 * f
                  }%)`,
                },
              ],
            },
          ];
        },
        Wiggle: function (t) {
          const { power: e, intensity: a = 0.5 } = t.namedEffect,
            r = t.duration || 0,
            n = t.delay || 0,
            o = (0, Xe._b)(0, 1, pa.soft, pa.hard, a),
            s = (e && pa[e]) || o;
          let i = 0;
          const c = ua.map((t) => {
            let { keyframe: e, transY: a, accRotate: o } = t;
            const c = {
              offset: (e / 100) * (r / (r + n)),
              transform: `rotate(calc(var(--comp-rotate-z, 0deg) + ${
                i + o * s
              }deg)) translateY(${a * s}px)`,
            };
            return (i += o * s), c;
          });
          return [{ ...t, delay: 0, duration: r + n, keyframes: c }];
        },
      };
      class ga {
        constructor(t, e) {
          (0, g.A)(this, "target", void 0),
            (0, g.A)(this, "options", void 0),
            (this.target = t),
            (this.options = e),
            this.play();
        }
        play() {
          this.options.transition &&
            (this.target.style.transition = this.options.transition);
        }
      }
      class ya extends ga {
        progress(t) {
          let { x: e, y: a } = t,
            r = 0,
            n = 0;
          const { distance: o, invert: s, angle: i, axis: c } = this.options;
          "vertical" !== c && (r = (0, Xe._b)(0, 1, -o.value, o.value, e) * s),
            "horizontal" !== c &&
              (n = (0, Xe._b)(0, 1, -o.value, o.value, a) * s);
          const l = (0, Xe._b)(0, 1, -i, i, e) * s,
            f = _(o.type);
          this.target.style.transform = `translateX(${r}${f}) translateY(${n}${f}) rotate(calc(${l}deg + var(--comp-rotate-z, 0deg)))`;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      class ha extends ga {
        progress(t) {
          let { x: e, y: a } = t;
          const { distance: r, scale: n, invert: o } = this.options,
            s = (0, Xe._b)(0, 1, -r.value, r.value, e) * o,
            i = (0, Xe._b)(0, 1, -r.value, r.value, a) * o,
            c =
              e < 0.5
                ? (0, Xe._b)(0, 0.5, n, 1, e)
                : (0, Xe._b)(0.5, 1, 1, n, e),
            l =
              a < 0.5
                ? (0, Xe._b)(0, 0.5, n, 1, a)
                : (0, Xe._b)(0.5, 1, 1, n, a),
            f = _(r.type);
          this.target.style.transform = `translateX(${s}${f}) translateY(${i}${f}) scale(${c}, ${l}) rotate(var(--comp-rotate-z, 0deg))`;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      class va extends ga {
        progress(t) {
          let { x: e, y: a } = t;
          const {
              distance: r,
              angle: n,
              scale: o,
              inverted: s,
              blur: i,
              perspective: c,
            } = this.options,
            l = s ? -1 : 1,
            f = (0, Xe._b)(0, 1, -r.value, r.value, e) * l,
            m = (0, Xe._b)(0, 1, -r.value, r.value, a) * l,
            p =
              e < 0.5
                ? (0, Xe._b)(0, 0.5, o, 1, e)
                : (0, Xe._b)(0.5, 1, 1, o, e),
            u =
              a < 0.5
                ? (0, Xe._b)(0, 0.5, o, 1, a)
                : (0, Xe._b)(0.5, 1, 1, o, a),
            d = Math.min(p, u),
            g = (0, Xe._b)(0, 1, -n, n, a) * l,
            y = (0, Xe._b)(0, 1, n, -n, e) * l,
            h = _(r.type),
            v = `perspective(${c}px) translateX(${f}${h}) translateY(${m}${h}) scale(${d}, ${d}) rotateX(${g}deg) rotateY(${y}deg) rotate(var(--comp-rotate-z, 0deg))`,
            $ = (0, Xe.Io)([0.5, 0.5], [e, a]),
            x = `blur(${Math.round((0, Xe._b)(0, 1, 0, i, (0, Y.T_)($)))}px)`;
          (this.target.style.transform = v), (this.target.style.filter = x);
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.filter = ""),
            (this.target.style.transition = "");
        }
      }
      class $a extends ga {
        progress(t) {
          let { x: e, y: a } = t;
          const { inverted: r, distance: n, axis: o } = this.options,
            s = r ? -1 : 1;
          let i = 0,
            c = 0;
          ("both" !== o && "horizontal" !== o) ||
            (i = (0, Xe._b)(0, 1, -n.value, n.value, e) * s),
            ("both" !== o && "vertical" !== o) ||
              (c = (0, Xe._b)(0, 1, -n.value, n.value, a) * s);
          const l = _(n.type);
          this.target.style.transform = `translateX(${i}${l}) translateY(${c}${l}) rotate(var(--comp-rotate-z, 0deg))`;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      function xa(t) {
        const { transitionDuration: e, transitionEasing: a } = t,
          {
            inverted: r = !1,
            distance: n = { value: 200, type: "px" },
            axis: o = "both",
          } = t.namedEffect,
          s = {
            transition: e ? `transform ${e}ms ${A(a)}` : "",
            inverted: r,
            distance: n,
            axis: o,
          };
        return (t) => new $a(t, s);
      }
      class ba extends ga {
        progress(t) {
          let { x: e, y: a } = t;
          const { distance: r, scale: n, inverted: o, axis: s } = this.options,
            i = o ? -1 : 1;
          let c = 0,
            l = 0,
            f = 1,
            m = 1;
          ("both" !== s && "horizontal" !== s) ||
            ((c = (0, Xe._b)(0, 1, -r.value, r.value, e) * i),
            (f =
              e < 0.5
                ? (0, Xe._b)(0, 0.5, n, 1, e)
                : (0, Xe._b)(0.5, 1, 1, n, e))),
            ("both" !== s && "vertical" !== s) ||
              ((l = (0, Xe._b)(0, 1, -r.value, r.value, a) * i),
              (m =
                a < 0.5
                  ? (0, Xe._b)(0, 0.5, n, 1, a)
                  : (0, Xe._b)(0.5, 1, 1, n, a)));
          const p = n < 1 ? Math.min(f, m) : Math.max(f, m),
            u = _(r.type);
          this.target.style.transform = `translateX(${c}${u}) translateY(${l}${u}) scale(${p}) rotate(var(--comp-rotate-z, 0deg))`;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      class ka extends ga {
        progress(t) {
          let { x: e, y: a } = t,
            r = 0,
            n = 0,
            o = 0,
            s = 0;
          const { distance: i, angle: c, axis: l, inverted: f } = this.options,
            m = f ? -1 : 1;
          "vertical" !== l &&
            ((r = (0, Xe._b)(0, 1, -i.value, i.value, e) * m),
            (o = (0, Xe._b)(0, 1, c, -c, e) * m)),
            "horizontal" !== l &&
              ((n = (0, Xe._b)(0, 1, -i.value, i.value, a) * m),
              (s = (0, Xe._b)(0, 1, c, -c, a) * m)),
            "both" === l &&
              ((o *= (0, Xe._b)(0, 1, 1, -1, (0, Y.tn)(a))),
              (s *= (0, Xe._b)(0, 1, 1, -1, (0, Y.tn)(e))));
          const p = _(i.type),
            u = `translateX(${r}${p}) translateY(${n}${p}) skew(${o}deg, ${s}deg) rotate(var(--comp-rotate-z, 0deg))`;
          this.target.style.transform = u;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      class wa extends ga {
        progress(t) {
          let { x: e, y: a } = t;
          const { invert: r, axis: n } = this.options,
            o =
              (0, Xe.Rb)(
                [0.5, 0.5],
                ["vertical" === n ? 0 : e, "horizontal" === n ? 0 : a],
                90
              ) * r;
          this.target.style.transform = `rotate(calc(${o}deg + var(--comp-rotate-z, 0deg)))`;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      const Ea = {
        top: [0, -50],
        bottom: [0, 50],
        right: [50, 0],
        left: [-50, 0],
        "center-horizontal": [0, 0],
        "center-vertical": [0, 0],
      };
      class Ya extends ga {
        progress(t) {
          let { x: e, y: a } = t,
            r = "rotateX",
            n = a,
            o = -1;
          const {
            pivotAxis: s,
            angle: i,
            invert: c,
            perspective: l,
          } = this.options;
          ("center-horizontal" !== s && "right" !== s && "left" !== s) ||
            ((r = "rotateY"), (n = e), (o = 1));
          const f = (0, Xe._b)(0, 1, -i, i, n) * o * c,
            [m, p] = Ea[s],
            u = `perspective(${l}px) translateX(${m}%) translateY(${p}%) ${r}(${f}deg) translateX(${-m}%) translateY(${-p}%) rotate(var(--comp-rotate-z, 0deg))`;
          this.target.style.transform = u;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      class Oa extends ga {
        progress(t) {
          let { x: e, y: a } = t;
          const { inverted: r, angle: n, perspective: o } = this.options,
            s = r ? -1 : 1,
            i = (0, Xe._b)(0, 1, n, -n, a) * s,
            c = (0, Xe._b)(0, 1, -n, n, e) * s;
          this.target.style.transform = `perspective(${o}px) rotateX(${i}deg) rotateY(${c}deg) rotate(var(--comp-rotate-z, 0deg))`;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      class Ia extends ga {
        progress(t) {
          let { x: e, y: a } = t;
          const {
              inverted: r,
              distance: n,
              angle: o,
              axis: s,
              perspective: i,
            } = this.options,
            c = r ? -1 : 1;
          let l = 0,
            f = 0,
            m = 0,
            p = 0;
          ("both" !== s && "horizontal" !== s) ||
            ((l = (0, Xe._b)(0, 1, -n.value, n.value, e)),
            (p = (0, Xe._b)(0, 1, -o, o, e) * c)),
            ("both" !== s && "vertical" !== s) ||
              ((f = (0, Xe._b)(0, 1, -n.value, n.value, a)),
              (m = (0, Xe._b)(0, 1, o, -o, a) * c));
          const u = _(n.type);
          this.target.style.transform = `perspective(${i}px) translateX(${l}${u}) translateY(${f}${u}) rotateX(${m}deg) rotateY(${p}deg) rotate(var(--comp-rotate-z, 0deg))`;
        }
        cancel() {
          (this.target.style.transform = ""),
            (this.target.style.transition = "");
        }
      }
      const Pa = {
        AiryMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              distance: n = { value: 200, type: "px" },
              angle: o = 30,
              axis: s = "both",
            } = t.namedEffect,
            i = r ? -1 : 1,
            c = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              invert: i,
              distance: n,
              angle: o,
              axis: s,
            };
          return (t) => new ya(t, c);
        },
        BlobMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              distance: n = { value: 200, type: "px" },
              scale: o = 1.4,
            } = t.namedEffect,
            s = r ? -1 : 1,
            i = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              invert: s,
              distance: n,
              scale: o,
            };
          return (t) => new ha(t, i);
        },
        BlurMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              distance: n = { value: 80, type: "px" },
              angle: o = 5,
              scale: s = 0.3,
              blur: i = 20,
              perspective: c = 600,
            } = t.namedEffect,
            l = {
              transition: e
                ? `transform ${e}ms ${A(a)}, filter ${e}ms ${A(a)}`
                : "",
              distance: n,
              angle: o,
              scale: s,
              blur: i,
              perspective: c,
              inverted: r,
            };
          return (t) => new va(t, l);
        },
        BounceMouse: function (t) {
          const { distance: e = { value: 80, type: "px" } } = t.namedEffect,
            { transitionEasing: a = "elastic" } = t;
          return xa({
            ...t,
            transitionEasing: a,
            namedEffect: { ...t.namedEffect, distance: e },
          });
        },
        ScaleMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              distance: n = { value: 80, type: "px" },
              axis: o = "both",
              scale: s = 1.4,
            } = t.namedEffect,
            i = r ? -1 : 1,
            c = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              invert: i,
              distance: n,
              axis: o,
              scale: s,
            };
          return (t) => new ba(t, c);
        },
        SkewMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              distance: n = { value: 200, type: "px" },
              angle: o = 25,
              axis: s = "both",
            } = t.namedEffect,
            i = r ? -1 : 1,
            c = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              invert: i,
              distance: n,
              angle: o,
              axis: s,
            };
          return (t) => new ka(t, c);
        },
        SpinMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a = "linear" } = t,
            { inverted: r = !1, axis: n = "both" } = t.namedEffect,
            o = r ? -1 : 1,
            s = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              invert: o,
              axis: n,
            };
          return (t) => new wa(t, s);
        },
        SwivelMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              angle: n = 5,
              perspective: o = 800,
              pivotAxis: s = "center-horizontal",
            } = t.namedEffect,
            i = r ? -1 : 1,
            c = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              invert: i,
              angle: n,
              perspective: o,
              pivotAxis: s,
            };
          return (t) => new Ya(t, c);
        },
        Tilt3DMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              angle: n = 5,
              perspective: o = 800,
            } = t.namedEffect,
            s = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              inverted: r,
              angle: n,
              perspective: o,
            };
          return (t) => new Oa(t, s);
        },
        Track3DMouse: function (t) {
          const { transitionDuration: e, transitionEasing: a } = t,
            {
              inverted: r = !1,
              distance: n = { value: 200, type: "px" },
              angle: o = 5,
              axis: s = "both",
              perspective: i = 800,
            } = t.namedEffect,
            c = {
              transition: e ? `transform ${e}ms ${A(a)}` : "",
              inverted: r,
              distance: n,
              angle: o,
              axis: s,
              perspective: i,
            };
          return (t) => new Ia(t, c);
        },
        TrackMouse: xa,
      };
      const za = {
        in: {
          startOffset: {
            name: "cover",
            offset: { type: "percentage", value: 0 },
          },
          endOffset: {
            name: "cover",
            offset: { type: "percentage", value: 50 },
          },
        },
        out: {
          startOffset: {
            name: "exit",
            offset: { type: "percentage", value: 0 },
          },
          endOffset: {
            name: "exit",
            offset: { type: "percentage", value: 100 },
          },
        },
      };
      const Xa = "100px";
      const _a = "100px",
        Sa = {
          in: {
            easing: "sineIn",
            fromY: "calc(0.5 * var(--motion-comp-height, 100%) - 50% - 100lvh)",
            toY: "calc(1.5 * var(--motion-comp-height, 100%) - 50%)",
            defaultZoom: 40,
          },
          out: {
            easing: "sineInOut",
            fromY: "0px",
            toY: "0px",
            defaultZoom: 15,
          },
        };
      const Ta = {
        BgCloseUp: function (t) {
          const e = "linear",
            { zoom: a = 80 } = t.namedEffect;
          return [
            {
              ...t,
              easing: e,
              part: "BG_MEDIA",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 50 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [{ opacity: 1 }, { opacity: 0 }],
            },
            {
              ...t,
              easing: e,
              part: "BG_MEDIA",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                { transform: "perspective(100px) translateZ(0px)" },
                { transform: `perspective(100px) translateZ(${a}px)` },
              ],
            },
          ];
        },
        BgFade: function (t) {
          const { range: e = "in" } = t.namedEffect,
            a = "out" === e,
            r = a ? 1 : 0,
            n = a ? 0 : 1,
            o = a ? "sineOut" : "sineIn",
            s = za[e];
          return [
            {
              ...t,
              part: "BG_LAYER",
              easing: o,
              ...s,
              keyframes: [{ opacity: r }, { opacity: n }],
            },
          ];
        },
        BgFadeBack: function (t) {
          const { scale: e = 0.7 } = t.namedEffect;
          return [
            {
              ...t,
              easing: "linear",
              part: "BG_LAYER",
              startOffset: {
                name: "exit",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "exit",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [{ opacity: 1 }, { opacity: 0 }],
            },
            {
              ...t,
              easing: "sineOut",
              part: "BG_LAYER",
              startOffset: {
                name: "exit",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "exit",
                offset: { type: "percentage", value: 50 },
              },
              keyframes: [{ scale: 1 }, { scale: e }],
            },
          ];
        },
        BgFake3D: function (t, e) {
          e && V(e);
          const { stretch: a = 1.3, zoom: r = 100 / 6 } = t.namedEffect;
          return [
            {
              ...t,
              part: "BG_MEDIA",
              easing: "linear",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                {
                  perspective: Xa,
                  transform:
                    "translateY(calc(0.5 * var(--motion-comp-height, 100%) - 50% - 100lvh))",
                },
                {
                  perspective: Xa,
                  transform:
                    "translateY(calc(1.5 * var(--motion-comp-height, 100%) - 50%))",
                },
              ],
            },
            {
              ...t,
              part: "BG_IMG",
              easing: "linear",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                {
                  transform:
                    "translateY(calc(50% - 0.5 * var(--motion-comp-height, 100%)))",
                },
                {
                  transform:
                    "translateY(calc(50% - 0.5 * var(--motion-comp-height, 100%)))",
                },
              ],
            },
            {
              ...t,
              part: "BG_IMG",
              easing: "sineOut",
              composite: "add",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                { transform: "translateY(10%)" },
                {
                  transform:
                    "translateY(calc(-0.07 * var(--motion-comp-height, 100%)))",
                },
              ],
            },
            {
              ...t,
              part: "BG_IMG",
              easing: "linear",
              composite: "add",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                { transform: `scaleY(${a})` },
                { transform: "scaleY(1)" },
              ],
            },
            {
              ...t,
              part: "BG_IMG",
              easing: "sineIn",
              composite: "add",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                { transform: "translateZ(0px)" },
                { transform: `translateZ(${r}px)` },
              ],
            },
          ];
        },
        BgPan: function (t) {
          const { direction: e = "left", speed: a = 0.2 } = t.namedEffect,
            r = (50 * a) / (1 + a);
          let n = `${r}%`,
            o = `-${r}%`;
          return (
            "right" === e && ([n, o] = [o, n]),
            [
              {
                ...t,
                part: "BG_MEDIA",
                startOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 0 },
                },
                endOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 100 },
                },
                keyframes: [
                  { transform: `translateX(${n})` },
                  { transform: `translateX(${o})` },
                ],
              },
            ]
          );
        },
        BgParallax: function (t, e) {
          e && V(e);
          const { speed: a = 0.2 } = t.namedEffect;
          return [
            {
              ...t,
              part: "BG_MEDIA",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                { transform: `translateY(-${100 * (1 - a)}lvh)` },
                {
                  transform: `translateY(calc(var(--motion-comp-height, 100%) * ${
                    1 - a
                  }))`,
                },
              ],
            },
          ];
        },
        BgPullBack: function (t) {
          const { zoom: e = 50 } = t.namedEffect;
          return [
            {
              ...t,
              easing: "linear",
              part: "BG_MEDIA",
              startOffset: {
                name: "entry",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "entry",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                {
                  transform: `perspective(100px) translate3d(0px, -${
                    e / 3
                  }%, ${e}px)`,
                },
                { transform: "perspective(100px) translate3d(0px, 0px, 0px)" },
              ],
            },
          ];
        },
        BgReveal: function (t, e) {
          return (
            e && V(e),
            [
              {
                ...t,
                part: "BG_MEDIA",
                startOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 0 },
                },
                endOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 100 },
                },
                keyframes: [
                  { transform: "translateY(-100lvh)" },
                  { transform: "translateY(var(--motion-comp-height, 100%))" },
                ],
              },
            ]
          );
        },
        BgRotate: function (t) {
          const { angle: e = 22, direction: a = "counter-clockwise" } =
            t.namedEffect;
          return [
            {
              ...t,
              easing: "sineOut",
              part: "BG_MEDIA",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "contain",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                {
                  transform: `rotate(${"counter-clockwise" === a ? e : -e}deg)`,
                },
                { transform: "rotate(0deg)" },
              ],
            },
          ];
        },
        BgSkew: function (t) {
          const { angle: e = 20, direction: a = "counter-clockwise" } =
            t.namedEffect;
          return [
            {
              ...t,
              part: "BG_MEDIA",
              startOffset: {
                name: "cover",
                offset: { type: "percentage", value: 0 },
              },
              endOffset: {
                name: "cover",
                offset: { type: "percentage", value: 100 },
              },
              keyframes: [
                {
                  transform: `skewY(${"counter-clockwise" === a ? e : -e}deg)`,
                },
                {
                  transform: `skewY(${"counter-clockwise" === a ? -e : e}deg)`,
                },
              ],
            },
          ];
        },
        BgZoom: function (t, e) {
          const { direction: a = "in" } = t.namedEffect,
            { easing: r, fromY: n, toY: o, defaultZoom: s } = Sa[a],
            { zoom: i = s } = t.namedEffect,
            c = "in" === a,
            l = c ? 0 : i / 1.3,
            f = c ? i : -i;
          return (
            e && c && V(e),
            [
              {
                ...t,
                part: c ? "BG_MEDIA" : "BG_LAYER",
                easing: "linear",
                startOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 0 },
                },
                endOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 100 },
                },
                keyframes: [{ perspective: _a }, { perspective: _a }],
              },
              {
                ...t,
                part: "BG_MEDIA",
                easing: "linear",
                startOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 0 },
                },
                endOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 100 },
                },
                keyframes: [
                  { transform: `translateY(${n})` },
                  { transform: `translateY(${o})` },
                ],
              },
              {
                ...t,
                easing: r,
                part: c ? "BG_IMG" : "BG_MEDIA",
                composite: c ? "replace" : "add",
                startOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 0 },
                },
                endOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 100 },
                },
                keyframes: [
                  {
                    transform: `${
                      c
                        ? "translateY(calc(70% - 0.5 * var(--motion-comp-height, 100%))) "
                        : ""
                    }translateZ(${l}px)`,
                  },
                  {
                    transform: `${
                      c
                        ? "translateY(calc(50% - 0.7 * var(--motion-comp-height, 100%))) "
                        : ""
                    }translateZ(${f}px)`,
                  },
                ],
              },
            ]
          );
        },
        ImageParallax: function (t) {
          const { speed: e = 1.5, reverse: a = !1 } = t.namedEffect;
          let r = (-100 * (e - 1)) / e,
            n = 0;
          return (
            a && ([r, n] = [n, r]),
            [
              {
                ...t,
                part: "BG_MEDIA",
                startOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 0 },
                },
                endOffset: {
                  name: "cover",
                  offset: { type: "percentage", value: 100 },
                },
                keyframes: [
                  { transform: `translateY(${r}%)` },
                  { transform: `translateY(${n}%)` },
                ],
              },
            ]
          );
        },
      };
      var Ma = a(17709),
        Aa = a.n(Ma);
      function Ba(t) {
        const e = t.alternate ? "alternate" : "";
        return t.reversed ? (e ? `${e}-` : "") + "reverse" : e || "normal";
      }
      function Va(t) {
        return `${t.value}${_(t.type)}`;
      }
      function Za(t, e, a) {
        return `${t.name} ${
          a && "percentage" !== t.offset.type
            ? `calc(100% + ${Va(t.offset)}${e ? ` + ${e}` : ""})`
            : e
            ? `calc(${Va(t.offset)} + ${e})`
            : Va(t.offset)
        }`;
      }
      function Ra(t) {
        return {
          start: Za(t.startOffset, t.startOffsetAdd),
          end: Za(t.endOffset, t.endOffsetAdd, !0),
        };
      }
      function Ca(t) {
        return t ? document.getElementById(t) : null;
      }
      function Fa(t) {
        return (e) => Aa().measure(() => e(t));
      }
      function Da(t) {
        return (e) => Aa().mutate(() => e(t));
      }
      function Ga(t, e) {
        if (t.namedEffect) {
          const a = t.namedEffect.type;
          let r;
          if (
            (a in Ft
              ? (r = Ft[a])
              : a in ze
              ? (r = ze[a])
              : a in da
              ? (r = da[a])
              : a in Pa
              ? (r = Pa[a])
              : a in Ta && (r = Ta[a]),
            r)
          ) {
            let a;
            return (
              e instanceof HTMLElement &&
                (a = { measure: Fa(e), mutate: Da(e) }),
              r(t, a)
            );
          }
        }
        return [];
      }
      class qa {
        constructor(t, e) {
          (0, g.A)(this, "animations", void 0),
            (0, g.A)(this, "options", void 0),
            (0, g.A)(this, "ready", void 0),
            (this.animations = t),
            (this.options = e),
            (this.ready =
              (null == e ? void 0 : e.measured) || Promise.resolve());
        }
        play(t) {
          this.ready
            .then(() => {
              for (const t of this.animations) t.play();
            })
            .then(() => Promise.all(this.animations.map((t) => t.ready)))
            .then(t);
        }
        pause() {
          for (const t of this.animations) t.pause();
        }
        reverse(t) {
          this.ready
            .then(() => {
              for (const t of this.animations) t.reverse();
            })
            .then(() => Promise.all(this.animations.map((t) => t.ready)))
            .then(t);
        }
        progress(t) {
          for (const e of this.animations) {
            const { activeDuration: a, delay: r } =
              e.effect.getComputedTiming();
            e.currentTime = ((r || 0) + (a || 0)) * t;
          }
        }
        cancel() {
          for (const t of this.animations) t.cancel();
        }
        onFinish(t) {
          Promise.all(this.animations.map((t) => t.finished)).then(t);
        }
      }
      function Ha(t, e) {
        return Ga(t, e).map((e) => {
          const a = {
            fill: e.fill,
            easing: S(e.easing),
            iterations: e.iterations || 1 / 0,
            composite: e.composite,
            direction: Ba(e),
          };
          return (
            e.type.startsWith("Time")
              ? ((a.duration = e.duration), (a.delay = e.delay || 0))
              : window.ViewTimeline
              ? (a.duration = "auto")
              : ((a.duration = 99.99), (a.delay = 0.01)),
            { effect: e, options: a, id: t.effectId, part: e.part }
          );
        });
      }
      function Wa(t, e, a) {
        const r = Ca(t);
        if ("pointer-move" === (null == a ? void 0 : a.trigger)) {
          return Ga(e, r)(r);
        }
        const n = Ha(e, r);
        let o;
        const s = "view-progress" === (null == a ? void 0 : a.trigger);
        let i, c;
        s &&
          window.ViewTimeline &&
          (o = new ViewTimeline({ subject: a.element || Ca(a.componentId) }));
        const l = n.map((t) => {
          let { effect: e, options: a, id: n, part: l } = t;
          const f = l
              ? null == r
                ? void 0
                : r.querySelector(`[data-motion-part="${l}"]`)
              : r,
            m = new KeyframeEffect(f || null, [], a);
          let p;
          if (
            (Aa().mutate(() => {
              "timing" in e && m.updateTiming(e.timing),
                m.setKeyframes(e.keyframes);
            }),
            (i = e.startOffsetAdd),
            (c = e.endOffsetAdd),
            s && o)
          ) {
            p = new Animation(m, o);
            const { start: t, end: a } = Ra(e);
            (p.rangeStart = t), (p.rangeEnd = a), p.play();
          } else p = new Animation(m);
          return n && (p.id = n), p;
        });
        return new qa(l, {
          ...e,
          trigger: { ...(a || {}) },
          startOffsetAdd: i,
          endOffsetAdd: c,
          measured: new Promise((t) => Aa().mutate(t)),
        });
      }
      function La(t, e) {
        const a = "string" == typeof t ? Ca(t) : t,
          r =
            null == a
              ? void 0
              : a.getAnimations().filter((t) => {
                  const a = t.id || t.animationName;
                  return !a || a.startsWith(e);
                });
        return null != r && r.length ? new qa(r) : null;
      }
      var Ua = a(789);
      function ja(t) {
        if (null == t) return window;
        const e = (function (t) {
          const e = window.getComputedStyle(t).overflowY;
          return "visible" !== e && "clip" !== e;
        })(t);
        return e ? t : ja(t.parentElement);
      }
      const Ja = (t, e) => ({
        getTargetAnimation(t, e) {
          return La(t, e);
        },
        play(t, e, a) {
          if (e.toggle) {
            const a = La(t, e.effectId);
            if (a) return a.reverse(), a;
          }
          const r = Wa(t, e);
          let n;
          return (
            a?.start?.length &&
              (n = () => {
                a.start.forEach((t) => t());
              }),
            a?.end?.length &&
              r.onFinish(() => {
                a.end.forEach((t) => t());
              }),
            r.play(n),
            r
          );
        },
        startScrub(t, e, a) {
          const r = new Map(),
            n = [],
            o = new Map(),
            s = [],
            i = "ViewTimeline" in window;
          function c(t, e, a) {
            const n = t(a);
            let o;
            i
              ? (o = document.documentElement)
              : (n.viewSource || (n.viewSource = e), (o = ja(e.parentElement))),
              r.has(o) || r.set(o, []),
              r.get(o).push(n);
          }
          function l(t, e, r, n, s) {
            const i = t(r, !a),
              c = "root" === s.hitArea,
              l = { isHitAreaRoot: c, effectId: n, ...i },
              f = c ? document.documentElement : e;
            o.has(f) || o.set(f, []), o.get(f).push(l);
          }
          return (
            Object.entries(t).forEach(([t, a]) => {
              const r = "view-progress" === a.trigger,
                n = "pointer-move" === a.trigger,
                { targetId: o, namedEffect: s } = e[t];
              if (s && (n || r)) {
                const n = document.getElementById(a.componentId);
                if (n) {
                  this._getScrubTargets(a.componentId, o).forEach((o) => {
                    const s = this._createScrub(e[t], { ...a, element: n });
                    return r
                      ? c(s.factory, n, o)
                      : l(s.factory, n, o, t, a.params);
                  });
                } else {
                  Array.from(
                    document.querySelectorAll(
                      `[id^="${a.componentId}${Ua.Jx}"]`
                    )
                  ).forEach((n) => {
                    const s = this._createScrub(e[t], { ...a, element: n }),
                      i = (0, Ua.Zr)((0, Ua.vC)(o), (0, Ua.HP)(n.id));
                    r ? c(s.factory, n, i) : l(s.factory, n, i, t, a.params);
                  });
                }
              }
            }),
            r.forEach((t, e) => {
              if (t.length)
                if (i) n.push(...t);
                else {
                  const a = new d.O({
                    root: e,
                    scenes: t,
                    observeViewportEntry: !1,
                    observeViewportResize: !1,
                    observeSourcesResize: !1,
                  });
                  a.start(), n.push(a);
                }
            }),
            o.forEach((t, e) => {
              const a = new m.g({
                root: e === document.documentElement ? void 0 : e,
                scenes: t,
              });
              a.start(), s.push(a);
            }),
            [...n, ...s]
          );
        },
        cancelScrub(t) {
          t.length && (t.forEach((t) => t.destroy()), (t.length = 0));
        },
        _createScrub(t, e) {
          return {
            targetId: t.targetId,
            factory: (a, r = !1) =>
              (function (t, e, a, r) {
                void 0 === r && (r = {});
                const { disabled: n } = r,
                  o = Wa(t, e, a),
                  { startOffset: s, endOffset: i, centeredToTarget: c } = e;
                let l = {};
                var f, m, p, u;
                return (
                  "view-progress" !== a.trigger || window.ViewTimeline
                    ? "pointer-move" === a.trigger &&
                      (l = { target: o.target, centeredToTarget: c })
                    : (l = {
                        start: s && {
                          name: s.name,
                          offset: null == (f = s.offset) ? void 0 : f.value,
                          add:
                            null == (m = o.options) ? void 0 : m.startOffsetAdd,
                        },
                        end: i && {
                          name: i.name,
                          offset: null == (p = i.offset) ? void 0 : p.value,
                          add:
                            null == (u = o.options) ? void 0 : u.endOffsetAdd,
                        },
                        viewSource: a.element || Ca(a.componentId),
                      }),
                  {
                    ...l,
                    effect(t, e) {
                      o.progress(e);
                    },
                    disabled: n,
                    destroy() {
                      o.cancel();
                    },
                  }
                );
              })(a || t.targetId, t, e, { disabled: r }),
          };
        },
        _getScrubTargets(a, r) {
          const n = t?.[r],
            { items: o = [] } = n && e ? e.get(n) : {};
          return o.length ? o.map((t) => (0, Ua.Zr)(r, t)) : [r];
        },
      });
      function Ka({ manager: t }) {
        const e = {
            entry: r(
              function (e) {
                const r = e
                  .filter((t) => {
                    const { isIntersecting: e, target: r } = t;
                    return e && (a.get(r).isIntersecting = !0), e;
                  })
                  .flatMap((t) => n(t.target));
                t.trigger({ resume: r });
              },
              0,
              "10%"
            ),
            exit: r(
              function (e) {
                const r = e
                  .filter((t) => {
                    const { isIntersecting: e, target: r } = t;
                    return e || (a.get(r).isIntersecting = !1), !e;
                  })
                  .flatMap((t) => n(t.target));
                t.trigger({ hold: r });
              },
              0,
              "50%"
            ),
          },
          a = new WeakMap();
        function r(t, e, a = "0px") {
          const r = { root: null, rootMargin: a, threshold: [e] };
          return new window.IntersectionObserver(t, r);
        }
        const n = (t) => Array.from(a.get(t)?.effects || []);
        return {
          observe: function (r, n) {
            const o = a.get(r);
            o
              ? (o.effects.add(n),
                o.isIntersecting && t.trigger({ resume: [n] }))
              : (a.set(r, { effects: new Set([n]), isIntersecting: !1 }),
                e.entry.observe(r),
                e.exit.observe(r));
          },
          disconnect: function () {
            e.entry.disconnect(), e.exit.disconnect();
          },
        };
      }
      const Na = (0, r.Og)(
        [(0, r.KT)(n.Gp, l.U), (0, r.KT)(n.wk, l.U), o.Is, s.Ji, i.RV, c.n],
        (t, e, a, r, n, o) => {
          const {
            animationDataByCompId: s,
            scrubAnimationBreakpoints: i,
            isResponsive: c,
          } = t;
          if (o || (0, f.fU)(n))
            return {
              name: "motion",
              async pageWillUnmount() {},
              getManager() {},
            };
          const l = Ja(t.repeaterTemplateToParentMap, r);
          let m = e.get()?.[a];
          m || ((m = new p(l, Ka, c)), e.update((t) => ({ ...t, [a]: m })));
          const u = Object.assign({}, ...Object.values(s || {}));
          return (
            m.init(u, i),
            {
              name: "motion",
              async pageWillUnmount() {
                m?.clear();
              },
              getManager() {
                return m;
              },
            }
          );
        }
      );
      var Qa = a(16537),
        tr = a(478);
      const er = (0, r.Og)([l.h, tr.e, i.RV, i.HW], (t, e, a, r) => ({
          getSdkHandlers: () => ({
            [l.U]: {
              runAnimation: async (n, o) => {
                const s = Array.isArray(n.targetId) ? n.targetId : [n.targetId];
                return new Promise(async (i) => {
                  const c = t.getManager(),
                    l = [];
                  if (!c) return void i();
                  const f = () => {
                      ar(a, s),
                        "in" === o &&
                          e.update(
                            s.reduce(
                              (t, e) => ({ ...t, [e]: { visibility: null } }),
                              {}
                            )
                          );
                    },
                    m = () => {
                      "out" === o &&
                        e.update(
                          s.reduce(
                            (t, e) => ({
                              ...t,
                              [e]: { visibility: "hidden !important" },
                            }),
                            {}
                          )
                        ),
                        rr(a, s),
                        setTimeout(() => {
                          l.forEach((t) => t.cancel()), (l.length = 0);
                        }, 0);
                    };
                  await r,
                    (n.fill = "both"),
                    s.forEach((t) => {
                      l.push(c.api.play(t, n, { start: [f], end: [m, i] }));
                    });
                });
              },
            },
          }),
        })),
        ar = (t, e) => {
          e.forEach((e) => {
            const a = t.document.getElementById(e);
            a && a.classList.add("is-animating");
          });
        },
        rr = (t, e) => {
          t.requestAnimationFrame(() => {
            e.forEach((e) => {
              const a = t.document.getElementById(e);
              a && a.classList.remove("is-animating");
            });
          });
        },
        nr = (t) => {
          t(i.H9).to(er), t(Qa.$.PageWillUnmountHandler, l.h).to(Na);
        };
    },
  },
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/motion.14ed46b0.chunk.min.js.map
